<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pool League Manager</title>
    
    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Pool League">
    <meta name="theme-color" content="#059669">
    <meta name="description" content="Manage your pool league - teams, schedules, scores, and standings">
    
    <!-- PWA Icons for iOS -->
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23059669' width='100' height='100' rx='20'/><text x='50' y='68' text-anchor='middle' font-size='50'>üèÜ</text></svg>">
    
    <!-- Manifest -->
    <link rel="manifest" href="data:application/json,{
        &quot;name&quot;: &quot;Pool League Manager&quot;,
        &quot;short_name&quot;: &quot;Pool League&quot;,
        &quot;description&quot;: &quot;Manage your pool league&quot;,
        &quot;start_url&quot;: &quot;.&quot;,
        &quot;display&quot;: &quot;standalone&quot;,
        &quot;background_color&quot;: &quot;%23059669&quot;,
        &quot;theme_color&quot;: &quot;%23059669&quot;,
        &quot;orientation&quot;: &quot;portrait&quot;,
        &quot;icons&quot;: [{
            &quot;src&quot;: &quot;data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%23059669' width='100' height='100' rx='20'/><text x='50' y='68' text-anchor='middle' font-size='50'>üèÜ</text></svg>&quot;,
            &quot;sizes&quot;: &quot;192x192&quot;,
            &quot;type&quot;: &quot;image/svg+xml&quot;
        }]
    }">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
        .tab-scroll::-webkit-scrollbar { height: 4px; }
        .tab-scroll::-webkit-scrollbar-thumb { background: #10b981; border-radius: 2px; }
        .loading-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 9999; }
        .spinner { width: 50px; height: 50px; border: 4px solid #fff; border-top-color: #10b981; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* PWA Styles */
        html, body { 
            overscroll-behavior: none; 
            -webkit-touch-callout: none;
        }
        /* Safe area for iPhone notch */
        body {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }
        /* Prevent pull-to-refresh */
        body.pwa-mode {
            overflow: hidden;
        }
        body.pwa-mode #app {
            overflow-y: auto;
            height: 100vh;
            height: 100dvh;
        }
        /* Install prompt banner */
        .install-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to right, #059669, #0d9488);
            color: white;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 9998;
            padding-bottom: calc(12px + env(safe-area-inset-bottom));
        }
    </style>
</head>
<body>
    <div id="app">
        <div style="min-height:100vh;display:flex;align-items:center;justify-content:center;background:linear-gradient(to bottom right,#0f172a,#064e3b,#134e4a);">
            <div style="text-align:center;color:white;">
                <div style="width:50px;height:50px;border:4px solid #fff;border-top-color:#10b981;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 16px;"></div>
                <p style="font-size:1.25rem;">Loading Pool League Manager...</p>
            </div>
        </div>
    </div>
    <div id="loading" class="loading-overlay" style="display:none;"><div class="spinner"></div></div>

    <script>
        // Wait for DOM and libraries to be ready
        document.addEventListener('DOMContentLoaded', function() {
            // Check if Supabase loaded
            if (typeof window.supabase === 'undefined') {
                document.getElementById('app').innerHTML = '<div style="padding:20px;color:red;text-align:center;"><h2>Error Loading</h2><p>Could not load required libraries. Please check your internet connection and refresh.</p></div>';
                return;
            }
            
            startApp();
        });
        
        function startApp() {
        console.log('Pool League Manager Loading (Supabase Edition)...');

        // ============================================
        // SUPABASE CONFIGURATION
        // ============================================
        const SUPABASE_URL = 'https://hprdhlletatixqysqegi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhwcmRobGxldGF0aXhxeXNxZWdpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgwOTU1NDMsImV4cCI6MjA4MzY3MTU0M30._wrv6ONjG3JRkpA1FDPFkKMSn0bi6vhMiR0UZB40IRk';
        
        let db;
        try {
            db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        } catch (e) {
            console.error('Failed to create Supabase client:', e);
            document.getElementById('app').innerHTML = '<div style="padding:20px;color:red;text-align:center;"><h2>Connection Error</h2><p>Could not connect to database. Please refresh the page.</p></div>';
            return;
        }

        // Loading helpers
        function showLoading() { document.getElementById('loading').style.display = 'flex'; }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }

        // ============================================
        // STATE
        // ============================================
        let state = {
            // Organization (multi-tenant)
            organization: null,
            
            // Multi-league support
            userLeagues: [],        // All leagues user has access to
            selectedLeague: null,   // Currently selected league
            showLeagueSelector: false, // Show league picker modal
            
            // Core data
            users: [],
            teams: [],
            schedule: [],
            submissions: [],
            matches: [],
            venues: [],
            seasons: [],
            currentSeason: null,
            currentUser: null,
            activeTab: 'schedule',
            leagueName: 'Pool League',
            showCreateTeam: false,
            showGenSchedule: false,
            showManageVenues: false,
            showManageSeasons: false,
            showArchivedSeasons: false,
            showFullSchedule: false,
            selectedHistoryMatch: null,
            standingsAdjustments: {}, // { teamId: { wins: +/- num, losses: +/- num, gamesWon: +/- num, gamesLost: +/- num } }
            editingStandings: false,
            playerStatsAdjustments: {}, // { playerId: { matchWins: +/-, matchLosses: +/-, gamesWon: +/-, gamesLost: +/- } }
            editingPlayerStats: false,
            editingUser: null, // User being edited { id, firstName, lastName, email, phone, role, teamId }
            showInviteResult: null, // { user, inviteUrl } - shown after creating user
            inviteToken: null, // Token from URL for account setup
            // Schedule creation mode: null, 'choose', 'manual', 'auto'
            scheduleMode: null,
            // Auto-generate sub-mode: null, 'roundrobin', 'customrr', 'csv'
            autoGenMode: null,
            // Custom Round Robin settings
            customRR: {
                matchesPerNight: 4,
                bestOf: 3,
                playDays: ['tuesday'],  // which days of week
                frequency: 'weekly',    // weekly, biweekly
                positionNights: 2,      // 0, 1, 2, or more
                positionNightPlacement: 'half', // 'half' (after each half), 'end' (all at end), 'start' (all at start)
                byePoints: 'win',       // 'win' (counts as a win) or 'none' (worth 0)
                timesToPlay: 2          // how many times each team faces every other team (1, 2, 3, 4)
            },
            // Manual match form data
            manualMatch: { week: '', date: '', homeTeamId: '', awayTeamId: '', venue: '', half: '1', isPositionNight: false, positionHome: '', positionAway: '' },
            // Manual entry mode: 'single' or 'week'
            manualEntryMode: 'single',
            // Week entry data - array of matches for batch entry
            weekMatches: [],
            selectedMatch: '',
            selectedTeam: '',
            matchups: Array(5).fill(null).map(() => ({ homePlayer: '', awayPlayer: '', homeGames: '', awayGames: '' })),
            initialized: false,
            // Play days for manual schedule entry (stored locally)
            playDays: JSON.parse(localStorage.getItem('plm_playDays') || '[2]') // Default Tuesday (0=Sun, 1=Mon, 2=Tue, etc.)
        };

        // ============================================
        // MANUAL ENTRY HELPER FUNCTIONS
        // ============================================
        
        function saveManualPlayDays(days) {
            state.playDays = days;
            localStorage.setItem('plm_playDays', JSON.stringify(days));
            render();
        }
        
        function toggleManualPlayDay(day) {
            const days = [...state.playDays];
            const idx = days.indexOf(day);
            if (idx >= 0) {
                days.splice(idx, 1);
            } else {
                days.push(day);
                days.sort((a, b) => a - b);
            }
            saveManualPlayDays(days);
        }
        
        function getNextWeekNumber() {
            try {
                if (!state.schedule || state.schedule.length === 0) return '1';
                const maxWeek = Math.max(...state.schedule.map(s => parseInt(s.week) || 0));
                return (maxWeek + 1).toString();
            } catch (error) {
                console.error('Error in getNextWeekNumber:', error);
                return '1';
            }
        }

        function getLastScheduleDate() {
            try {
                if (!state.schedule || state.schedule.length === 0) return null;
                const sorted = [...state.schedule].sort((a, b) => new Date(b.date) - new Date(a.date));
                return sorted[0]?.date || null;
            } catch (error) {
                console.error('Error in getLastScheduleDate:', error);
                return null;
            }
        }

        function getNextPlayDate(fromDate = null) {
            try {
                const playDays = state.playDays || [2]; // Default to Tuesday
                if (!playDays || playDays.length === 0) {
                    // Return today's date if no play days configured
                    return new Date().toISOString().split('T')[0];
                }
                
                let startDate;
                if (fromDate) {
                    startDate = new Date(fromDate + 'T12:00:00'); // Use noon to avoid timezone issues
                    startDate.setDate(startDate.getDate() + 1); // Start from day after
                } else {
                    const lastDate = getLastScheduleDate();
                    if (lastDate) {
                        startDate = new Date(lastDate + 'T12:00:00');
                        startDate.setDate(startDate.getDate() + 1);
                    } else {
                        startDate = new Date();
                    }
                }
                
                // Find the next play day
                for (let i = 0; i < 14; i++) { // Look up to 2 weeks ahead
                    const checkDate = new Date(startDate);
                    checkDate.setDate(checkDate.getDate() + i);
                    if (playDays.includes(checkDate.getDay())) {
                        return checkDate.toISOString().split('T')[0];
                    }
                }
                
                return startDate.toISOString().split('T')[0];
            } catch (error) {
                console.error('Error in getNextPlayDate:', error);
                return new Date().toISOString().split('T')[0];
            }
        }
        
        function initManualEntryDefaults() {
            try {
                if (!state.manualMatch.week) {
                    state.manualMatch.week = getNextWeekNumber();
                }
                if (!state.manualMatch.date) {
                    state.manualMatch.date = getNextPlayDate();
                }
                // Set half from last schedule entry (or default to '1')
                if (!state.manualMatch.half || state.manualMatch.half === '1') {
                    const lastHalf = getLastScheduleHalf();
                    if (lastHalf) {
                        state.manualMatch.half = lastHalf.toString();
                    }
                }
            } catch (error) {
                console.error('Error in initManualEntryDefaults:', error);
            }
        }
        
        function getLastScheduleHalf() {
            try {
                if (!state.schedule || state.schedule.length === 0) return 1;
                // Get the most recently added entry (by highest week number, then by date)
                const sorted = [...state.schedule].sort((a, b) => {
                    const weekDiff = parseInt(b.week) - parseInt(a.week);
                    if (weekDiff !== 0) return weekDiff;
                    return new Date(b.date) - new Date(a.date);
                });
                return sorted[0]?.half || 1;
            } catch (error) {
                console.error('Error in getLastScheduleHalf:', error);
                return 1;
            }
        }
        
        function advanceToNextWeek() {
            const nextWeek = (parseInt(state.manualMatch.week || '0') + 1).toString();
            
            // Add exactly 7 days to advance to next week
            if (state.manualMatch.date) {
                const currentDate = new Date(state.manualMatch.date + 'T12:00:00'); // Use noon to avoid timezone issues
                currentDate.setDate(currentDate.getDate() + 7);
                state.manualMatch.date = currentDate.toISOString().split('T')[0];
            } else {
                state.manualMatch.date = getNextPlayDate();
            }
            
            state.manualMatch.week = nextWeek;
            render();
        }
        
        // ============================================
        // WEEK ENTRY HELPER FUNCTIONS
        // ============================================
        
        function initWeekMatches() {
            const numTeams = (state.teams || []).length;
            const numMatches = Math.floor(numTeams / 2);
            const hasBye = numTeams % 2 === 1;
            
            // Create empty match slots
            state.weekMatches = [];
            for (let i = 0; i < numMatches; i++) {
                state.weekMatches.push({
                    homeTeamId: '',
                    awayTeamId: '',
                    venue: ''
                });
            }
            
            // Add bye slot if odd number of teams
            if (hasBye) {
                state.weekMatches.push({
                    homeTeamId: '',
                    awayTeamId: 'BYE',
                    venue: 'BYE WEEK',
                    isBye: true
                });
            }
        }
        
        function updateWeekMatch(index, field, value) {
            if (!state.weekMatches[index]) return;
            state.weekMatches[index][field] = value;
            
            // Auto-fill venue when home team is selected
            if (field === 'homeTeamId' && value) {
                const team = (state.teams || []).find(t => t.id === value);
                if (team && team.venue && !state.weekMatches[index].isBye) {
                    state.weekMatches[index].venue = team.venue;
                }
            }
            
            render();
        }
        
        function getUsedTeamsInWeek() {
            const used = new Set();
            state.weekMatches.forEach(m => {
                if (m.homeTeamId) used.add(m.homeTeamId);
                if (m.awayTeamId && m.awayTeamId !== 'BYE') used.add(m.awayTeamId);
            });
            return used;
        }
        
        function getAvailableTeamsForSlot(currentMatch, field) {
            const usedTeams = getUsedTeamsInWeek();
            const currentValue = currentMatch[field];
            const otherField = field === 'homeTeamId' ? 'awayTeamId' : 'homeTeamId';
            const otherValue = currentMatch[otherField];
            
            return (state.teams || []).filter(t => {
                // Always show currently selected team
                if (t.id === currentValue) return true;
                // Don't show if already used elsewhere
                if (usedTeams.has(t.id)) return false;
                // Don't show if it's the other team in this match
                if (t.id === otherValue) return false;
                return true;
            }).sort((a, b) => a.name.localeCompare(b.name));
        }
        
        function validateWeekMatches() {
            const m = state.manualMatch;
            if (!m.week || !m.date) {
                alert('Please enter week number and date');
                return false;
            }
            
            // Check that all slots are filled
            for (let i = 0; i < state.weekMatches.length; i++) {
                const match = state.weekMatches[i];
                if (!match.homeTeamId) {
                    alert(`Match ${i + 1}: Please select a home team`);
                    return false;
                }
                if (!match.awayTeamId && !match.isBye) {
                    alert(`Match ${i + 1}: Please select an away team`);
                    return false;
                }
            }
            
            // Check for duplicate teams
            const usedTeams = new Set();
            for (const match of state.weekMatches) {
                if (usedTeams.has(match.homeTeamId)) {
                    const team = state.teams.find(t => t.id === match.homeTeamId);
                    alert(`${team?.name || 'A team'} is scheduled twice in this week!`);
                    return false;
                }
                usedTeams.add(match.homeTeamId);
                
                if (match.awayTeamId && match.awayTeamId !== 'BYE') {
                    if (usedTeams.has(match.awayTeamId)) {
                        const team = state.teams.find(t => t.id === match.awayTeamId);
                        alert(`${team?.name || 'A team'} is scheduled twice in this week!`);
                        return false;
                    }
                    usedTeams.add(match.awayTeamId);
                }
            }
            
            return true;
        }
        
        async function addWeekMatches() {
            if (!validateWeekMatches()) return;
            
            if (!state.currentSeason?.id) {
                alert('Please create or select a season first');
                return;
            }
            
            if (!state.organization?.id) {
                alert('No organization loaded');
                return;
            }
            
            const m = state.manualMatch;
            
            showLoading();
            try {
                const scheduleEntries = state.weekMatches.map(match => {
                    const homeTeam = state.teams.find(t => t.id === match.homeTeamId);
                    const isBye = match.isBye || match.awayTeamId === 'BYE';
                    
                    return {
                        week: m.week,
                        date: m.date,
                        home_team_id: match.homeTeamId,
                        away_team_id: isBye ? 'BYE' : match.awayTeamId,
                        venue: isBye ? 'BYE WEEK' : (match.venue || homeTeam?.venue || 'TBD'),
                        is_bye: isBye,
                        half: parseInt(m.half) || 1,
                        is_position_night: false,
                        season_id: state.currentSeason.id,
                        org_id: state.organization.id
                    };
                });
                
                const { data, error } = await db.from('schedule').insert(scheduleEntries).select();
                
                if (error) throw error;
                
                // Add to local state
                data.forEach(entry => {
                    state.schedule.push({
                        id: entry.id,
                        week: entry.week,
                        date: entry.date,
                        homeTeamId: entry.home_team_id,
                        awayTeamId: entry.away_team_id,
                        venue: entry.venue,
                        isBye: entry.is_bye,
                        half: entry.half,
                        isPositionNight: entry.is_position_night,
                        seasonId: entry.season_id,
                        orgId: entry.org_id
                    });
                });
                
                // Sort schedule by week
                state.schedule.sort((a, b) => parseInt(a.week) - parseInt(b.week));
                
                // Advance to next week and reset matches
                const currentHalf = m.half;
                const nextWeek = (parseInt(m.week) + 1).toString();
                
                // Add exactly 7 days for next week
                const currentDate = new Date(m.date + 'T12:00:00');
                currentDate.setDate(currentDate.getDate() + 7);
                const nextDate = currentDate.toISOString().split('T')[0];
                
                state.manualMatch = { 
                    week: nextWeek, 
                    date: nextDate, 
                    homeTeamId: '', 
                    awayTeamId: '', 
                    venue: '', 
                    half: currentHalf 
                };
                
                // Re-init week matches for next week
                initWeekMatches();
                
                alert(`Added ${data.length} matches for Week ${m.week}!`);
                render();
            } catch (error) {
                console.error('Error adding week matches:', error);
                alert('Error adding matches: ' + error.message);
            } finally {
                hideLoading();
            }
        }
        
        async function addPositionNightMatches() {
            const m = state.manualMatch;
            
            if (!m.week || !m.date) {
                alert('Please fill in week and date');
                return;
            }
            
            if (!state.currentSeason?.id) {
                alert('Please create or select a season first');
                return;
            }
            
            if (!state.organization?.id) {
                alert('No organization loaded');
                return;
            }
            
            const numTeams = (state.teams || []).length;
            if (numTeams < 2) {
                alert('You need at least 2 teams');
                return;
            }
            
            const numMatches = Math.floor(numTeams / 2);
            const hasBye = numTeams % 2 === 1;
            
            showLoading();
            try {
                const scheduleEntries = [];
                
                // Generate position matchups: 1st vs 2nd, 3rd vs 4th, etc.
                for (let i = 0; i < numMatches; i++) {
                    const homePosition = i * 2 + 1;  // 1st, 3rd, 5th... (higher seed hosts)
                    const awayPosition = i * 2 + 2;  // 2nd, 4th, 6th...
                    
                    scheduleEntries.push({
                        week: m.week,
                        date: m.date,
                        home_team_id: `POSITION_${homePosition}`,
                        away_team_id: `POSITION_${awayPosition}`,
                        venue: 'TBD - Based on Standings',
                        is_bye: false,
                        half: parseInt(m.half) || 1,
                        is_position_night: true,
                        position_home: homePosition,
                        position_away: awayPosition,
                        season_id: state.currentSeason.id,
                        org_id: state.organization.id
                    });
                }
                
                // Add BYE for last place if odd number of teams
                if (hasBye) {
                    scheduleEntries.push({
                        week: m.week,
                        date: m.date,
                        home_team_id: `POSITION_${numTeams}`,
                        away_team_id: 'BYE',
                        venue: 'BYE WEEK',
                        is_bye: true,
                        half: parseInt(m.half) || 1,
                        is_position_night: true,
                        position_home: numTeams,
                        position_away: null,
                        season_id: state.currentSeason.id,
                        org_id: state.organization.id
                    });
                }
                
                const { data, error } = await db.from('schedule').insert(scheduleEntries).select();
                
                if (error) throw error;
                
                // Add to local state
                data.forEach(entry => {
                    state.schedule.push({
                        id: entry.id,
                        week: entry.week,
                        date: entry.date,
                        homeTeamId: entry.home_team_id,
                        awayTeamId: entry.away_team_id,
                        venue: entry.venue,
                        isBye: entry.is_bye,
                        half: entry.half,
                        isPositionNight: entry.is_position_night,
                        positionHome: entry.position_home,
                        positionAway: entry.position_away,
                        seasonId: entry.season_id,
                        orgId: entry.org_id
                    });
                });
                
                // Sort schedule by week
                state.schedule.sort((a, b) => parseInt(a.week) - parseInt(b.week));
                
                // Advance to next week
                const currentHalf = m.half;
                const nextWeek = (parseInt(m.week) + 1).toString();
                
                // Add exactly 7 days for next week
                const currentDate = new Date(m.date + 'T12:00:00');
                currentDate.setDate(currentDate.getDate() + 7);
                const nextDate = currentDate.toISOString().split('T')[0];
                
                state.manualMatch = { 
                    week: nextWeek, 
                    date: nextDate, 
                    homeTeamId: '', 
                    awayTeamId: '', 
                    venue: '', 
                    half: currentHalf,
                    isPositionNight: false,
                    positionHome: '',
                    positionAway: ''
                };
                
                alert(`Position Night added! ${numMatches} matches${hasBye ? ' + 1 BYE' : ''} for Week ${m.week}`);
                render();
            } catch (error) {
                console.error('Error adding position night:', error);
                alert('Error adding position night: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // DATABASE OPERATIONS
        // ============================================
        
        // Helper functions for mapping DB records to app format
        function mapScheduleFromDB(s) {
            return {
                id: s.id, week: s.week, date: s.date, 
                homeTeamId: s.home_team_id, awayTeamId: s.away_team_id, 
                venue: s.venue || 'TBD', isBye: s.is_bye,
                half: s.half, isPositionNight: s.is_position_night,
                positionHome: s.position_home, positionAway: s.position_away,
                seasonId: s.season_id, orgId: s.org_id,
                matchFormat: s.match_format || null
            };
        }
        
        function mapMatchFromDB(m) {
            return {
                id: m.id, scheduleId: m.schedule_id, 
                homeScore: m.home_score, awayScore: m.away_score,
                matchups: m.matchups || [], timestamp: m.created_at,
                markedPlayed: m.marked_played || false
            };
        }
        
        function mapSubmissionFromDB(s) {
            return {
                id: s.id, scheduleId: s.schedule_id, teamId: s.team_id,
                homeScore: s.home_score, awayScore: s.away_score,
                matchups: s.matchups || [], timestamp: s.created_at
            };
        }
        
        async function loadAllData() {
            showLoading();
            try {
                const orgId = state.organization?.id;
                if (!orgId) {
                    console.error('No organization loaded');
                    hideLoading();
                    return;
                }

                const { data: settings, error: settingsError } = await db.from('league_settings')
                    .select('*')
                    .eq('org_id', orgId)
                    .limit(1)
                    .single();
                console.log('Settings:', settings, settingsError);
                if (settings) {
                    state.leagueName = settings.name;
                    state.venues = settings.venues || [];
                }

                // Load seasons for this org
                const { data: seasons } = await db.from('seasons')
                    .select('*')
                    .eq('org_id', orgId)
                    .order('created_at', { ascending: false });
                state.seasons = (seasons || []).map(s => ({
                    id: s.id, name: s.name, startDate: s.start_date, endDate: s.end_date,
                    isActive: s.is_active, isArchived: s.is_archived || false, createdAt: s.created_at, orgId: s.org_id,
                    standingsAdjustments: s.standings_adjustments || {},
                    playerStatsAdjustments: s.player_stats_adjustments || {}
                }));
                
                // Set current season to active non-archived one, or most recent non-archived
                const activeNonArchived = state.seasons.find(s => s.isActive && !s.isArchived);
                const anyNonArchived = state.seasons.find(s => !s.isArchived);
                state.currentSeason = activeNonArchived || anyNonArchived || state.seasons[0] || null;

                const { data: users, error: usersError } = await db.from('users')
                    .select('*')
                    .eq('org_id', orgId);
                console.log('Users:', users, usersError);
                state.users = (users || []).map(u => ({
                    id: u.id, email: u.email, password: u.password, phone: u.phone,
                    firstName: u.first_name || '', lastName: u.last_name || '',
                    role: u.role, teamId: u.team_id, playerId: u.player_id,
                    createdAt: u.created_at, createdBy: u.created_by, orgId: u.org_id,
                    inviteToken: u.invite_token, status: u.status || 'active'
                }));

                const { data: teams, error: teamsError } = await db.from('teams')
                    .select('*')
                    .eq('org_id', orgId);
                console.log('Teams:', teams, teamsError);
                state.teams = (teams || []).map(t => ({
                    id: t.id, name: t.name, venue: t.venue || '', captain: t.captain || '',
                    phone: t.phone || '', players: t.players || [], orgId: t.org_id
                }));

                // Load schedule for current season
                await loadSeasonData();

                state.initialized = true;
                console.log('Data loaded:', { org: orgId, users: state.users.length, teams: state.teams.length, schedule: state.schedule.length, venues: state.venues.length, seasons: state.seasons.length });
            } catch (error) {
                console.error('Error loading data:', error);
                state.initialized = true;
            } finally {
                hideLoading();
            }
        }

        async function loadSeasonData() {
            const seasonId = state.currentSeason?.id;
            
            // Load standings adjustments from current season
            state.standingsAdjustments = state.currentSeason?.standingsAdjustments || {};
            state.playerStatsAdjustments = state.currentSeason?.playerStatsAdjustments || {};
            
            if (seasonId) {
                const { data: schedule } = await db.from('schedule').select('*').eq('season_id', seasonId);
                state.schedule = (schedule || []).map(mapScheduleFromDB);

                const { data: submissions } = await db.from('submissions').select('*').eq('season_id', seasonId);
                state.submissions = (submissions || []).map(mapSubmissionFromDB);

                const { data: matches } = await db.from('matches').select('*').eq('season_id', seasonId);
                state.matches = (matches || []).map(mapMatchFromDB);
            } else {
                // No season - load all data (backwards compatibility)
                const { data: schedule } = await db.from('schedule').select('*');
                state.schedule = (schedule || []).map(mapScheduleFromDB);

                const { data: submissions } = await db.from('submissions').select('*');
                state.submissions = (submissions || []).map(mapSubmissionFromDB);

                const { data: matches } = await db.from('matches').select('*');
                state.matches = (matches || []).map(mapMatchFromDB);
            }
        }

        async function saveLeagueName(name) {
            showLoading();
            try {
                const { data: settings } = await db.from('league_settings').select('id').limit(1).single();
                await db.from('league_settings').update({ name }).eq('id', settings.id);
                state.leagueName = name;
                render();
            } catch (error) {
                console.error('Error saving league name:', error);
                alert('Error saving settings');
            } finally {
                hideLoading();
            }
        }

        async function saveStandingsAdjustments() {
            if (!state.currentSeason?.id) {
                alert('No season selected');
                return;
            }
            
            showLoading();
            try {
                const { error } = await db.from('seasons')
                    .update({ standings_adjustments: state.standingsAdjustments })
                    .eq('id', state.currentSeason.id);
                
                if (error) throw error;
                
                // Update local season data
                state.currentSeason.standingsAdjustments = state.standingsAdjustments;
                const seasonIdx = state.seasons.findIndex(s => s.id === state.currentSeason.id);
                if (seasonIdx !== -1) {
                    state.seasons[seasonIdx].standingsAdjustments = state.standingsAdjustments;
                }
                
                alert('Standings adjustments saved!');
                state.editingStandings = false;
                render();
            } catch (error) {
                console.error('Error saving standings adjustments:', error);
                alert('Error saving adjustments: ' + (error.message || 'Unknown error'));
            } finally {
                hideLoading();
            }
        }

        function updateStandingsAdjustment(teamId, field, value) {
            const numValue = parseInt(value) || 0;
            if (!state.standingsAdjustments[teamId]) {
                state.standingsAdjustments[teamId] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0 };
            }
            state.standingsAdjustments[teamId][field] = numValue;
            render();
        }

        function quickAdjust(teamId, winsDelta, lossesDelta) {
            if (!state.standingsAdjustments[teamId]) {
                state.standingsAdjustments[teamId] = { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0 };
            }
            state.standingsAdjustments[teamId].wins += winsDelta;
            state.standingsAdjustments[teamId].losses += lossesDelta;
            render();
        }

        async function savePlayerStatsAdjustments() {
            if (!state.currentSeason?.id) {
                alert('No season selected');
                return;
            }
            
            showLoading();
            try {
                const { error } = await db.from('seasons')
                    .update({ player_stats_adjustments: state.playerStatsAdjustments })
                    .eq('id', state.currentSeason.id);
                
                if (error) throw error;
                
                // Update local season data
                state.currentSeason.playerStatsAdjustments = state.playerStatsAdjustments;
                const seasonIdx = state.seasons.findIndex(s => s.id === state.currentSeason.id);
                if (seasonIdx !== -1) {
                    state.seasons[seasonIdx].playerStatsAdjustments = state.playerStatsAdjustments;
                }
                
                alert('Player stats adjustments saved!');
                state.editingPlayerStats = false;
                render();
            } catch (error) {
                console.error('Error saving player stats adjustments:', error);
                alert('Error saving adjustments: ' + (error.message || 'Unknown error'));
            } finally {
                hideLoading();
            }
        }

        function updatePlayerStatsAdjustment(playerId, field, value) {
            const numValue = parseInt(value) || 0;
            if (!state.playerStatsAdjustments[playerId]) {
                state.playerStatsAdjustments[playerId] = { matchWins: 0, matchLosses: 0, gamesWon: 0, gamesLost: 0 };
            }
            state.playerStatsAdjustments[playerId][field] = numValue;
            render();
        }

        function quickPlayerAdjust(playerId, matchWinsDelta, matchLossesDelta) {
            if (!state.playerStatsAdjustments[playerId]) {
                state.playerStatsAdjustments[playerId] = { matchWins: 0, matchLosses: 0, gamesWon: 0, gamesLost: 0 };
            }
            state.playerStatsAdjustments[playerId].matchWins += matchWinsDelta;
            state.playerStatsAdjustments[playerId].matchLosses += matchLossesDelta;
            render();
        }

        async function addVenue(name, address, phone) {
            if (!name || !name.trim()) {
                alert('Please enter a venue name');
                return false;
            }
            name = name.trim();
            
            // Check if venue name already exists
            const exists = state.venues.some(v => {
                const venueName = typeof v === 'string' ? v : v.name;
                return venueName.toLowerCase() === name.toLowerCase();
            });
            
            if (exists) {
                alert('Venue already exists');
                return false;
            }
            
            showLoading();
            try {
                const newVenue = { 
                    name: name, 
                    address: (address || '').trim(), 
                    phone: (phone || '').trim() 
                };
                const newVenues = [...state.venues, newVenue];
                const { data: settings } = await db.from('league_settings').select('id').limit(1).single();
                await db.from('league_settings').update({ venues: newVenues }).eq('id', settings.id);
                state.venues = newVenues;
                render();
                return true;
            } catch (error) {
                console.error('Error adding venue:', error);
                alert('Error adding venue');
                return false;
            } finally {
                hideLoading();
            }
        }

        async function deleteVenue(venueName) {
            if (!confirm('Delete venue "' + venueName + '"?')) return;
            showLoading();
            try {
                const newVenues = state.venues.filter(v => {
                    const name = typeof v === 'string' ? v : v.name;
                    return name !== venueName;
                });
                const { data: settings } = await db.from('league_settings').select('id').limit(1).single();
                await db.from('league_settings').update({ venues: newVenues }).eq('id', settings.id);
                state.venues = newVenues;
                render();
            } catch (error) {
                console.error('Error deleting venue:', error);
                alert('Error deleting venue');
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // SEASON FUNCTIONS
        // ============================================
        async function createSeason(name) {
            if (!name || !name.trim()) {
                alert('Please enter a season name');
                return false;
            }
            if (!state.organization?.id) { alert('No organization loaded'); return false; }
            
            showLoading();
            try {
                // Deactivate all other seasons for this org
                await db.from('seasons').update({ is_active: false }).eq('org_id', state.organization.id);
                
                // Create new active season
                const { data, error } = await db.from('seasons').insert([{
                    name: name.trim(),
                    is_active: true,
                    org_id: state.organization.id
                }]).select().single();
                
                if (error) throw error;
                
                const newSeason = {
                    id: data.id,
                    name: data.name,
                    startDate: data.start_date,
                    endDate: data.end_date,
                    isActive: data.is_active,
                    createdAt: data.created_at,
                    orgId: data.org_id
                };
                
                state.seasons = [newSeason, ...state.seasons.map(s => ({ ...s, isActive: false }))];
                state.currentSeason = newSeason;
                state.schedule = [];
                state.matches = [];
                state.submissions = [];
                
                alert('Season "' + name + '" created and set as active!');
                render();
                return true;
            } catch (error) {
                console.error('Error creating season:', error);
                alert('Error creating season');
                return false;
            } finally {
                hideLoading();
            }
        }

        async function switchSeason(seasonId) {
            const season = state.seasons.find(s => s.id === seasonId);
            if (!season) return;
            
            showLoading();
            try {
                state.currentSeason = season;
                await loadSeasonData();
                render();
            } catch (error) {
                console.error('Error switching season:', error);
                alert('Error switching season');
            } finally {
                hideLoading();
            }
        }

        async function setActiveSeason(seasonId) {
            showLoading();
            try {
                // Deactivate all seasons
                await db.from('seasons').update({ is_active: false }).neq('id', '00000000-0000-0000-0000-000000000000');
                
                // Activate selected season
                await db.from('seasons').update({ is_active: true }).eq('id', seasonId);
                
                state.seasons = state.seasons.map(s => ({
                    ...s,
                    isActive: s.id === seasonId
                }));
                
                const season = state.seasons.find(s => s.id === seasonId);
                state.currentSeason = season;
                await loadSeasonData();
                
                alert('Season "' + season.name + '" is now active!');
                render();
            } catch (error) {
                console.error('Error setting active season:', error);
                alert('Error setting active season');
            } finally {
                hideLoading();
            }
        }

        async function deleteSeason(seasonId) {
            const season = state.seasons.find(s => s.id === seasonId);
            if (!season) return;
            
            showLoading();
            try {
                // Delete all data for this season
                await db.from('matches').delete().eq('season_id', seasonId);
                await db.from('submissions').delete().eq('season_id', seasonId);
                await db.from('schedule').delete().eq('season_id', seasonId);
                await db.from('seasons').delete().eq('id', seasonId);
                
                state.seasons = state.seasons.filter(s => s.id !== seasonId);
                
                // If we deleted the current season, switch to another
                if (state.currentSeason?.id === seasonId) {
                    const activeSeason = state.seasons.find(s => s.isActive && !s.isArchived);
                    const anySeason = state.seasons.find(s => !s.isArchived) || state.seasons[0];
                    state.currentSeason = activeSeason || anySeason;
                    if (state.currentSeason) {
                        await loadSeasonData();
                    }
                }
                
                alert('Season deleted permanently.');
                render();
            } catch (error) {
                console.error('Error deleting season:', error);
                alert('Error deleting season');
            } finally {
                hideLoading();
            }
        }

        // Archive a season (hide it but keep data)
        async function archiveSeason(seasonId) {
            const season = state.seasons.find(s => s.id === seasonId);
            if (!season) return;
            
            showLoading();
            try {
                const { error } = await db.from('seasons')
                    .update({ is_archived: true, is_active: false })
                    .eq('id', seasonId);
                
                if (error) throw error;
                
                season.isArchived = true;
                season.isActive = false;
                
                // If we archived the current season, switch to another
                if (state.currentSeason?.id === seasonId) {
                    const activeSeason = state.seasons.find(s => s.isActive && !s.isArchived);
                    const anySeason = state.seasons.find(s => !s.isArchived);
                    state.currentSeason = activeSeason || anySeason;
                    if (state.currentSeason) {
                        await loadSeasonData();
                    }
                }
                
                alert(`Season "${season.name}" has been archived. You can view archived seasons in Settings.`);
                render();
            } catch (error) {
                console.error('Error archiving season:', error);
                alert('Error archiving season');
            } finally {
                hideLoading();
            }
        }
        
        // Unarchive a season
        async function unarchiveSeason(seasonId) {
            const season = state.seasons.find(s => s.id === seasonId);
            if (!season) return;
            
            showLoading();
            try {
                const { error } = await db.from('seasons')
                    .update({ is_archived: false })
                    .eq('id', seasonId);
                
                if (error) throw error;
                
                season.isArchived = false;
                alert(`Season "${season.name}" has been restored.`);
                render();
            } catch (error) {
                console.error('Error unarchiving season:', error);
                alert('Error restoring season');
            } finally {
                hideLoading();
            }
        }

        // Smart delete/archive handler
        async function confirmDeleteSeason(seasonId, seasonName) {
            const season = state.seasons.find(s => s.id === seasonId);
            if (!season) return;
            
            // Check if season has any completed matches
            const { count: matchCount } = await db.from('matches')
                .select('*', { count: 'exact', head: true })
                .eq('season_id', seasonId);
            
            const hasMatches = matchCount && matchCount > 0;
            
            if (hasMatches) {
                // Season has started - can only archive
                const confirmMsg = `Season "${seasonName}" has ${matchCount} completed match${matchCount > 1 ? 'es' : ''}.\n\n` +
                    `Seasons with match history cannot be deleted to preserve records.\n\n` +
                    `Would you like to ARCHIVE this season instead?\n` +
                    `‚Ä¢ Archived seasons are hidden from the main view\n` +
                    `‚Ä¢ All data is preserved\n` +
                    `‚Ä¢ You can restore it later from Settings`;
                
                if (confirm(confirmMsg)) {
                    await archiveSeason(seasonId);
                }
            } else {
                // No matches - can delete, but with confirmation
                const nonArchivedSeasons = state.seasons.filter(s => !s.isArchived);
                
                if (nonArchivedSeasons.length <= 1 && !season.isArchived) {
                    alert('Cannot delete the only active season. Create a new season first, or archive this one.');
                    return;
                }
                
                const confirmMsg = `Delete season "${seasonName}"?\n\n` +
                    `This season has no match results, so it can be permanently deleted.\n\n` +
                    `This will remove:\n` +
                    `‚Ä¢ All schedule entries\n` +
                    `‚Ä¢ All pending submissions\n\n` +
                    `This cannot be undone. Continue?`;
                
                if (confirm(confirmMsg)) {
                    await deleteSeason(seasonId);
                }
            }
        }

        // Generate schedule for a NEW season (doesn't overwrite current)
        async function generateNewSeasonSchedule() {
            const seasonName = document.getElementById('new-season-name-gen')?.value?.trim();
            const startDate = document.getElementById('gen-start-date')?.value;
            
            if (!seasonName) {
                alert('Please enter a season name');
                return;
            }
            if (!startDate) {
                alert('Please select a start date');
                return;
            }
            if (state.teams.length < 2) {
                alert('Need at least 2 teams to generate a schedule');
                return;
            }
            if (!state.organization?.id) {
                alert('No organization loaded');
                return;
            }
            
            // Check for duplicate name
            if (state.seasons.find(s => s.name.toLowerCase() === seasonName.toLowerCase())) {
                alert('A season with this name already exists. Please choose a different name.');
                return;
            }
            
            showLoading();
            try {
                const orgId = state.organization.id;
                
                // 1. Archive current active season (don't delete it)
                if (state.currentSeason?.isActive) {
                    await db.from('seasons').update({ is_active: false }).eq('id', state.currentSeason.id);
                }
                
                // 2. Create new season
                const { data: newSeasonData, error: seasonError } = await db.from('seasons').insert([{
                    name: seasonName,
                    is_active: true,
                    org_id: orgId
                }]).select().single();
                
                if (seasonError) throw seasonError;
                
                const newSeason = {
                    id: newSeasonData.id,
                    name: newSeasonData.name,
                    startDate: newSeasonData.start_date,
                    endDate: newSeasonData.end_date,
                    isActive: true,
                    createdAt: newSeasonData.created_at,
                    orgId: newSeasonData.org_id
                };
                
                // 3. Generate schedule for new season
                const numTeams = state.teams.length;
                const weeksPerHalf = numTeams % 2 === 1 ? numTeams : numTeams - 1;
                const schedule = generateRoundRobinSchedule(startDate, weeksPerHalf);
                
                const dbSchedule = schedule.map(s => ({
                    week: s.week, date: s.date, home_team_id: s.homeTeamId,
                    away_team_id: s.awayTeamId, venue: s.venue, is_bye: s.isBye,
                    half: s.half, is_position_night: s.isPositionNight,
                    position_home: s.positionHome, position_away: s.positionAway,
                    season_id: newSeason.id,
                    org_id: orgId
                }));
                
                const { data: scheduleData } = await db.from('schedule').insert(dbSchedule).select();
                
                // 4. Update state
                state.seasons = [newSeason, ...state.seasons.map(s => ({ ...s, isActive: false }))];
                state.currentSeason = newSeason;
                state.schedule = scheduleData.map(s => ({
                    id: s.id, week: s.week, date: s.date, homeTeamId: s.home_team_id,
                    awayTeamId: s.away_team_id, venue: s.venue, isBye: s.is_bye,
                    half: s.half, isPositionNight: s.is_position_night,
                    positionHome: s.position_home, positionAway: s.position_away,
                    seasonId: s.season_id, orgId: s.org_id
                }));
                state.matches = [];
                state.submissions = [];
                state.showGenSchedule = false;
                
                alert(`‚úÖ Season "${seasonName}" created!\n\n${weeksPerHalf * 2 + 2} weeks generated.\n\nYour previous season has been archived and is still accessible.`);
                render();
            } catch (error) {
                console.error('Error creating season:', error);
                alert('Error creating season: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // AUTH FUNCTIONS
        // ============================================
        
        // Helper function to get display name for a user
        function getUserDisplayName(user) {
            if (!user) return 'Unknown';
            const fullName = [user.firstName, user.lastName].filter(Boolean).join(' ');
            return fullName || user.email || 'Unknown';
        }
        
        async function login(email, password) {
            showLoading();
            try {
                // Find user by email and password
                const { data: users, error } = await db.from('users')
                    .select('*')
                    .eq('email', email)
                    .eq('password', password)
                    .limit(1);
                
                if (error) throw error;
                if (!users || users.length === 0) {
                    hideLoading();
                    return false;
                }
                
                const userData = users[0];
                const user = {
                    id: userData.id, email: userData.email, password: userData.password,
                    firstName: userData.first_name || '', lastName: userData.last_name || '',
                    phone: userData.phone, role: userData.role, teamId: userData.team_id,
                    playerId: userData.player_id, createdAt: userData.created_at,
                    createdBy: userData.created_by, orgId: userData.org_id
                };
                
                state.currentUser = user;
                localStorage.setItem('plm_session', JSON.stringify({ id: user.id }));
                
                // Track login statistics
                try {
                    await db.from('users').update({ 
                        last_login: new Date().toISOString(),
                        login_count: (userData.login_count || 0) + 1
                    }).eq('id', user.id);
                } catch (e) {
                    console.log('Login tracking not available:', e);
                }
                
                // Check for league memberships (new multi-league system)
                const leagues = await getUserLeagues(user.id);
                
                if (leagues.length === 0) {
                    // Fall back to legacy org_id method
                    if (user.orgId) {
                        await loadOrganizationAndData(user.orgId);
                    } else {
                        hideLoading();
                        alert('No league access found. Contact your league administrator.');
                        return false;
                    }
                } else if (leagues.length === 1) {
                    // Auto-select the only league
                    state.userLeagues = leagues;
                    await selectLeague(leagues[0]);
                } else {
                    // Multiple leagues - show selector
                    state.userLeagues = leagues;
                    state.showLeagueSelector = true;
                    hideLoading();
                    render();
                    return true; // Login successful, but need league selection
                }
                
                render();
                return true;
            } catch (error) {
                console.error('Login error:', error);
                hideLoading();
                return false;
            }
        }
        
        // Get all leagues a user has access to
        async function getUserLeagues(userId) {
            try {
                // First try the new league_memberships table
                const { data: memberships, error } = await db.from('league_memberships')
                    .select(`
                        id,
                        league_id,
                        team_id,
                        role,
                        is_active,
                        leagues:league_id (
                            id,
                            name,
                            organization_id,
                            organizations:organization_id (
                                id,
                                name,
                                slug,
                                subscription_status,
                                subscription_tier
                            )
                        ),
                        teams:team_id (
                            id,
                            name
                        )
                    `)
                    .eq('user_id', userId)
                    .eq('is_active', true);
                
                if (error) {
                    console.log('League memberships table not found, using legacy method');
                    return await getUserLeaguesLegacy(userId);
                }
                
                if (!memberships || memberships.length === 0) {
                    return await getUserLeaguesLegacy(userId);
                }
                
                return memberships.map(m => ({
                    membershipId: m.id,
                    leagueId: m.leagues?.id || m.league_id,
                    leagueName: m.leagues?.name || 'Unknown League',
                    orgId: m.leagues?.organization_id,
                    orgName: m.leagues?.organizations?.name || 'Unknown Organization',
                    teamId: m.team_id,
                    teamName: m.teams?.name || null,
                    role: m.role,
                    subscriptionStatus: m.leagues?.organizations?.subscription_status
                }));
            } catch (e) {
                console.log('Error loading league memberships:', e);
                return await getUserLeaguesLegacy(userId);
            }
        }
        
        // Legacy method: get leagues from user's org_id
        async function getUserLeaguesLegacy(userId) {
            const user = state.users.find(u => u.id === userId) || state.currentUser;
            if (!user?.orgId) return [];
            
            try {
                // Get all leagues in user's org
                const { data: leagues } = await db.from('leagues')
                    .select('*, organizations:organization_id(*)')
                    .eq('organization_id', user.orgId);
                
                if (!leagues || leagues.length === 0) {
                    // No leagues table, treat org as single league
                    const { data: org } = await db.from('organizations')
                        .select('*')
                        .eq('id', user.orgId)
                        .single();
                    
                    if (org) {
                        return [{
                            leagueId: null, // No separate league, just org
                            leagueName: org.name,
                            orgId: org.id,
                            orgName: org.name,
                            teamId: user.teamId,
                            teamName: null,
                            role: user.role,
                            subscriptionStatus: org.subscription_status,
                            isLegacy: true
                        }];
                    }
                }
                
                return (leagues || []).map(l => ({
                    leagueId: l.id,
                    leagueName: l.name,
                    orgId: l.organization_id,
                    orgName: l.organizations?.name || 'Unknown',
                    teamId: user.teamId,
                    teamName: null,
                    role: user.role,
                    subscriptionStatus: l.organizations?.subscription_status
                }));
            } catch (e) {
                console.log('Error in legacy league lookup:', e);
                return [];
            }
        }
        
        // Select a league and load its data
        async function selectLeague(league) {
            showLoading();
            try {
                state.selectedLeague = league;
                state.showLeagueSelector = false;
                
                // Update user's team context if specified in membership
                if (league.teamId && state.currentUser) {
                    state.currentUser.teamId = league.teamId;
                }
                
                // Update user's role context if specified
                if (league.role && state.currentUser) {
                    // Map membership role to app role
                    if (league.role === 'captain') {
                        state.currentUser.role = 'captain';
                    } else if (league.role === 'player') {
                        state.currentUser.role = 'player';
                    }
                    // admin/owner roles preserved from user record
                }
                
                // Load organization and all data
                await loadOrganizationAndData(league.orgId, league.leagueId);
                
                // Save league selection for session restore
                localStorage.setItem('plm_selected_league', JSON.stringify({
                    leagueId: league.leagueId,
                    orgId: league.orgId
                }));
                
                render();
            } catch (error) {
                console.error('Error selecting league:', error);
                alert('Error loading league data');
            } finally {
                hideLoading();
            }
        }
        
        // Load organization and optionally filter by league
        async function loadOrganizationAndData(orgId, leagueId = null) {
            const { data: org, error: orgError } = await db.from('organizations')
                .select('*')
                .eq('id', orgId)
                .single();
            
            if (orgError) throw orgError;
            
            state.organization = {
                id: org.id,
                name: org.name,
                slug: org.slug,
                subscriptionStatus: org.subscription_status,
                subscriptionTier: org.subscription_tier,
                billingInterval: org.billing_interval,
                trialEndsAt: org.trial_ends_at,
                maxTeams: org.max_teams,
                maxUsers: org.max_users,
                maxSeasons: org.max_seasons
            };
            
            // Store league filter if specified
            if (leagueId) {
                state.selectedLeague = state.selectedLeague || {};
                state.selectedLeague.leagueId = leagueId;
            }
            
            // Check subscription status
            const isValid = checkSubscriptionValid();
            if (!isValid) {
                hideLoading();
                alert('Your subscription has expired. Please contact your administrator to renew.');
                return false;
            }
            
            // Load all org data
            await loadAllData();
            return true;
        }
        
        function checkSubscriptionValid() {
            if (!state.organization) return false;
            
            const status = state.organization.subscriptionStatus;
            
            // Active subscription
            if (status === 'active') return true;
            
            // Valid trial
            if (status === 'trial') {
                const trialEnd = new Date(state.organization.trialEndsAt);
                if (trialEnd > new Date()) return true;
            }
            
            return false;
        }

        function logout() {
            state.currentUser = null;
            state.userLeagues = [];
            state.selectedLeague = null;
            state.showLeagueSelector = false;
            state.activeTab = 'schedule';
            localStorage.removeItem('plm_session');
            localStorage.removeItem('plm_selected_league');
            render();
        }

        // Generate a random invite token
        function generateInviteToken() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghjkmnpqrstuvwxyz23456789';
            let token = '';
            for (let i = 0; i < 32; i++) {
                token += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return token;
        }
        
        // Get the base URL for invite links
        function getInviteUrl(token) {
            const baseUrl = window.location.origin + window.location.pathname;
            return baseUrl + '?invite=' + token;
        }
        
        // Send invite email via Edge Function
        async function sendInviteEmail(user, inviteUrl) {
            try {
                const response = await fetch(`${SUPABASE_URL}/functions/v1/send-invite-email`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${SUPABASE_ANON_KEY}`
                    },
                    body: JSON.stringify({
                        to: user.email,
                        firstName: user.firstName,
                        lastName: user.lastName,
                        leagueName: state.leagueName || 'Pool League',
                        inviteUrl: inviteUrl
                    })
                });
                
                const result = await response.json();
                
                if (!result.success) {
                    console.error('Failed to send invite email:', result.error);
                    return false;
                }
                
                console.log('Invite email sent:', result.messageId);
                return true;
            } catch (error) {
                console.error('Error sending invite email:', error);
                return false;
            }
        }
        
        // Create a new user with invite token (no password required initially)
        async function inviteUser(email, phone, role = 'player', teamId = null, firstName = '', lastName = '') {
            if (!email) { alert('Email is required'); return null; }
            if (!phone || phone.replace(/\D/g, '').length < 10) { alert('Valid phone number required (10+ digits)'); return null; }
            if (state.users.find(u => u.email === email)) { alert('Email already exists'); return null; }
            if (!state.organization?.id) { alert('No organization loaded'); return null; }

            showLoading();
            try {
                const inviteToken = generateInviteToken();
                
                const { data, error } = await db.from('users').insert([{
                    email, 
                    phone,
                    first_name: firstName || null,
                    last_name: lastName || null,
                    role: role || 'player',
                    team_id: teamId || null,
                    org_id: state.organization.id,
                    created_by: state.currentUser?.id || null,
                    invite_token: inviteToken,
                    status: 'pending'
                }]).select().single();

                if (error) throw error;

                const user = {
                    id: data.id, 
                    email: data.email, 
                    firstName: data.first_name || '', 
                    lastName: data.last_name || '',
                    phone: data.phone, 
                    role: data.role, 
                    teamId: data.team_id,
                    createdAt: data.created_at, 
                    createdBy: data.created_by, 
                    orgId: data.org_id,
                    inviteToken: data.invite_token,
                    status: data.status || 'pending'
                };

                state.users = [...state.users, user];
                
                const inviteUrl = getInviteUrl(inviteToken);
                
                // Send invite email (don't block on failure)
                const emailSent = await sendInviteEmail(user, inviteUrl);
                
                render();
                
                return {
                    user,
                    inviteUrl,
                    emailSent
                };
            } catch (error) {
                console.error('Error inviting user:', error);
                alert('Error inviting user: ' + error.message);
                return null;
            } finally {
                hideLoading();
            }
        }
        
        // Resend invite - generates new token and sends email
        async function resendInvite(userId) {
            const user = state.users.find(u => u.id === userId);
            if (!user) return null;
            
            showLoading();
            try {
                const newToken = generateInviteToken();
                
                await db.from('users').update({
                    invite_token: newToken,
                    status: 'pending'
                }).eq('id', userId);
                
                // Update local state
                const updatedUser = { ...user, inviteToken: newToken, status: 'pending' };
                state.users = state.users.map(u => u.id === userId ? updatedUser : u);
                
                const inviteUrl = getInviteUrl(newToken);
                
                // Send invite email
                await sendInviteEmail(updatedUser, inviteUrl);
                
                render();
                return inviteUrl;
            } catch (error) {
                console.error('Error resending invite:', error);
                alert('Error resending invite: ' + error.message);
                return null;
            } finally {
                hideLoading();
            }
        }
        
        // Complete invite - set password and activate account
        async function completeInvite(token, password) {
            if (!token) { alert('Invalid invite link'); return null; }
            if (!password || password.length < 4) { alert('Password must be at least 4 characters'); return null; }
            
            showLoading();
            try {
                // Find user by token
                const { data: users, error: findError } = await db.from('users')
                    .select('*')
                    .eq('invite_token', token)
                    .limit(1);
                
                if (findError) throw findError;
                if (!users || users.length === 0) {
                    alert('Invalid or expired invite link. Please contact your league administrator.');
                    return null;
                }
                
                const userData = users[0];
                
                // Update user with password and clear token
                const { error: updateError } = await db.from('users').update({
                    password: password,
                    invite_token: null,
                    status: 'active'
                }).eq('id', userData.id);
                
                if (updateError) throw updateError;
                
                alert('Account activated! You can now sign in with your email and password.');
                return {
                    email: userData.email,
                    orgId: userData.org_id
                };
            } catch (error) {
                console.error('Error completing invite:', error);
                alert('Error setting up account: ' + error.message);
                return null;
            } finally {
                hideLoading();
            }
        }

        // Legacy createAccount for backwards compatibility and admin self-registration
        async function createAccount(email, password, phone, role = null, teamId = null, firstName = '', lastName = '') {
            if (!email || !password) { alert('Email and password required'); return false; }
            if (!phone || phone.length < 10) { alert('Valid phone number required (10+ digits)'); return false; }
            if (state.users.find(u => u.email === email)) { alert('Email already exists'); return false; }
            if (!state.organization?.id) { alert('No organization loaded'); return false; }

            showLoading();
            try {
                // All users are players unless specified
                const finalRole = role || 'player';
                
                const { data, error } = await db.from('users').insert([{
                    email, password, phone,
                    first_name: firstName || null,
                    last_name: lastName || null,
                    role: finalRole,
                    team_id: teamId || null,
                    org_id: state.organization.id,
                    created_by: state.currentUser?.id || null,
                    status: 'active'
                }]).select().single();

                if (error) throw error;

                const user = {
                    id: data.id, email: data.email, password: data.password,
                    firstName: data.first_name || '', lastName: data.last_name || '',
                    phone: data.phone, role: data.role, teamId: data.team_id,
                    createdAt: data.created_at, createdBy: data.created_by, orgId: data.org_id,
                    status: data.status || 'active'
                };

                state.users = [...state.users, user];

                const displayName = [firstName, lastName].filter(Boolean).join(' ') || email;
                alert('User "' + displayName + '" created as ' + finalRole + '!');
                render();
                return true;
            } catch (error) {
                console.error('Error creating account:', error);
                alert('Error creating account: ' + error.message);
                return false;
            } finally {
                hideLoading();
            }
        }

        async function deleteUser(userId) {
            if (userId === state.currentUser.id) { alert('Cannot delete yourself'); return; }
            const user = state.users.find(u => u.id === userId);
            if (!confirm(`Delete user "${getUserDisplayName(user)}"?`)) return;

            showLoading();
            try {
                await db.from('users').delete().eq('id', userId);
                state.users = state.users.filter(u => u.id !== userId);
                render();
            } catch (error) {
                console.error('Error deleting user:', error);
                alert('Error deleting user');
            } finally {
                hideLoading();
            }
        }

        async function resetPassword(userId) {
            const user = state.users.find(u => u.id === userId);
            if (!user) return;
            
            const displayName = getUserDisplayName(user);
            const newPassword = prompt(`Enter new password for "${displayName}":\n\n(Minimum 4 characters)`);
            if (!newPassword) return;
            if (newPassword.length < 4) { alert('Password must be at least 4 characters'); return; }
            
            showLoading();
            try {
                await db.from('users').update({ password: newPassword }).eq('id', userId);
                state.users = state.users.map(u => u.id === userId ? { ...u, password: newPassword } : u);
                alert(`Password reset for "${displayName}"!\n\nNew password: ${newPassword}\n\nShare this with the user.`);
                render();
            } catch (error) {
                console.error('Error resetting password:', error);
                alert('Error resetting password');
            } finally {
                hideLoading();
            }
        }
        
        // Open edit modal for a user
        function editUser(userId) {
            const user = state.users.find(u => u.id === userId);
            if (!user) return;
            
            // Check permissions: admin can edit anyone, captain can edit their team members
            const isAdmin = state.currentUser.role === 'admin';
            const isCaptain = state.currentUser.role === 'captain';
            const isOwnTeam = user.teamId === state.currentUser.teamId;
            const isSelf = user.id === state.currentUser.id;
            
            if (!isAdmin && !isSelf && !(isCaptain && isOwnTeam)) {
                alert('You do not have permission to edit this user');
                return;
            }
            
            state.editingUser = {
                id: user.id,
                firstName: user.firstName || '',
                lastName: user.lastName || '',
                email: user.email || '',
                phone: user.phone || '',
                role: user.role || 'player',
                teamId: user.teamId || ''
            };
            render();
        }
        
        // Close edit modal
        function cancelEditUser() {
            state.editingUser = null;
            render();
        }
        
        // Save edited user
        async function saveUser() {
            const edit = state.editingUser;
            if (!edit) return;
            
            // Validation
            if (!edit.email) { alert('Email is required'); return; }
            if (!edit.phone || edit.phone.replace(/\D/g, '').length < 10) { 
                alert('Valid phone number required (10+ digits)'); return; 
            }
            
            // Check if email changed and is unique
            const existingUser = state.users.find(u => u.email === edit.email && u.id !== edit.id);
            if (existingUser) {
                alert('Email already in use by another user');
                return;
            }
            
            showLoading();
            try {
                const updateData = {
                    first_name: edit.firstName || null,
                    last_name: edit.lastName || null,
                    email: edit.email,
                    phone: edit.phone,
                    role: edit.role,
                    team_id: edit.teamId || null
                };
                
                await db.from('users').update(updateData).eq('id', edit.id);
                
                // Update local state
                state.users = state.users.map(u => {
                    if (u.id === edit.id) {
                        return {
                            ...u,
                            firstName: edit.firstName,
                            lastName: edit.lastName,
                            email: edit.email,
                            phone: edit.phone,
                            role: edit.role,
                            teamId: edit.teamId || null
                        };
                    }
                    return u;
                });
                
                // If editing self, update currentUser too
                if (edit.id === state.currentUser.id) {
                    state.currentUser = {
                        ...state.currentUser,
                        firstName: edit.firstName,
                        lastName: edit.lastName,
                        email: edit.email,
                        phone: edit.phone,
                        role: edit.role,
                        teamId: edit.teamId || null
                    };
                }
                
                state.editingUser = null;
                alert('User updated successfully!');
                render();
            } catch (error) {
                console.error('Error updating user:', error);
                alert('Error updating user: ' + error.message);
            } finally {
                hideLoading();
            }
        }
        
        // Update editing user field
        function updateEditingUser(field, value) {
            if (!state.editingUser) return;
            state.editingUser[field] = value;
            render();
        }

        async function selfServiceReset(email, phone) {
            if (!email || !phone) { alert('Email and phone required'); return false; }
            
            showLoading();
            try {
                // Look up user by email and verify phone
                const { data: users, error } = await db.from('users')
                    .select('*')
                    .eq('email', email)
                    .limit(1);
                
                if (error) throw error;
                
                if (!users || users.length === 0) {
                    alert('Email not found');
                    return false;
                }
                
                const user = users[0];
                
                // Normalize phone numbers for comparison (remove all non-digits)
                const storedPhone = (user.phone || '').replace(/\D/g, '');
                const inputPhone = phone.replace(/\D/g, '');
                
                if (storedPhone !== inputPhone) {
                    alert('Phone number does not match our records');
                    return false;
                }
                
                // Phone verified - prompt for new password
                const newPassword = prompt('Phone verified! Enter your new password:\n\n(Minimum 4 characters)');
                if (!newPassword) return false;
                if (newPassword.length < 4) { alert('Password must be at least 4 characters'); return false; }
                
                await db.from('users').update({ password: newPassword }).eq('id', user.id);
                alert('Password reset successfully! You can now log in with your new password.');
                return true;
            } catch (error) {
                console.error('Error resetting password:', error);
                alert('Error resetting password');
                return false;
            } finally {
                hideLoading();
            }
        }

        async function assignTeam(userId, teamId) {
            showLoading();
            try {
                await db.from('users').update({ team_id: teamId || null }).eq('id', userId);
                state.users = state.users.map(u => u.id === userId ? { ...u, teamId: teamId || null } : u);
                render();
            } catch (error) {
                console.error('Error assigning team:', error);
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // TEAM FUNCTIONS
        // ============================================
        async function createTeam(name, venue, captain) {
            if (!name) { alert('Team name required'); return false; }
            if (!state.organization?.id) { alert('No organization loaded'); return false; }

            showLoading();
            try {
                const { data, error } = await db.from('teams').insert([{
                    name, venue: venue || '', captain: captain || '', players: [],
                    org_id: state.organization.id
                }]).select().single();

                if (error) throw error;

                const newTeam = {
                    id: data.id, name: data.name, venue: data.venue,
                    captain: data.captain, players: data.players || [], orgId: data.org_id
                };
                
                state.teams = [...state.teams, newTeam];

                // Auto-assign captain to this team (captain here is an email)
                if (captain) {
                    const captainUser = state.users.find(u => u.email === captain);
                    if (captainUser) {
                        await db.from('users').update({ team_id: newTeam.id }).eq('id', captainUser.id);
                        state.users = state.users.map(u => u.id === captainUser.id ? { ...u, teamId: newTeam.id } : u);
                    }
                }

                state.showCreateTeam = false;
                alert('Team "' + name + '" created!');
                render();
                return true;
            } catch (error) {
                console.error('Error creating team:', error);
                alert('Error creating team: ' + error.message);
                return false;
            } finally {
                hideLoading();
            }
        }

        async function deleteTeam(teamId) {
            const team = state.teams.find(t => t.id === teamId);
            if (!confirm(`Delete team "${team.name}"?`)) return;

            showLoading();
            try {
                await db.from('users').update({ team_id: null }).eq('team_id', teamId);
                await db.from('teams').delete().eq('id', teamId);
                state.teams = state.teams.filter(t => t.id !== teamId);
                state.users = state.users.map(u => u.teamId === teamId ? { ...u, teamId: null } : u);
                render();
            } catch (error) {
                console.error('Error deleting team:', error);
            } finally {
                hideLoading();
            }
        }

        async function setTeamCaptain(teamId) {
            const selectEl = document.getElementById(`captain-select-${teamId}`);
            const captainName = selectEl?.value;
            
            if (!captainName) {
                alert('Please select a player to be captain');
                return;
            }
            
            const team = state.teams.find(t => t.id === teamId);
            if (!team) return;
            
            showLoading();
            try {
                // Update team's captain field
                await db.from('teams').update({ captain: captainName }).eq('id', teamId);
                state.teams = state.teams.map(t => t.id === teamId ? { ...t, captain: captainName } : t);
                
                // Find the player object to get their ID
                const player = team.players.find(p => p.name === captainName);
                
                // Find the corresponding user (by playerId or matching email/name)
                let captainUser = null;
                if (player) {
                    captainUser = state.users.find(u => u.playerId === player.id);
                }
                if (!captainUser) {
                    // Fallback: try to find user by matching email or name
                    captainUser = state.users.find(u => u.email === captainName || getUserDisplayName(u) === captainName);
                }
                
                // Update user's role to 'captain' if found and not already admin
                if (captainUser && captainUser.role !== 'admin') {
                    await db.from('users').update({ role: 'captain' }).eq('id', captainUser.id);
                    state.users = state.users.map(u => u.id === captainUser.id ? { ...u, role: 'captain' } : u);
                    console.log(`Updated ${getUserDisplayName(captainUser)} role to captain`);
                }
                
                render();
                alert(`${captainName} is now the captain of ${team.name}`);
            } catch (error) {
                console.error('Error setting captain:', error);
                alert('Error setting captain: ' + (error.message || 'Unknown error'));
            } finally {
                hideLoading();
            }
        }

        async function addPlayer(teamId, playerName) {
            if (!playerName.trim()) return;

            showLoading();
            try {
                const team = state.teams.find(t => t.id === teamId);
                const playerId = Date.now().toString();
                const newPlayers = [...team.players, { id: playerId, name: playerName }];

                await db.from('teams').update({ players: newPlayers }).eq('id', teamId);
                state.teams = state.teams.map(t => t.id === teamId ? { ...t, players: newPlayers } : t);
                render();
            } catch (error) {
                console.error('Error adding player:', error);
            } finally {
                hideLoading();
            }
        }

        async function removePlayer(teamId, playerId) {
            const team = state.teams.find(t => t.id === teamId);
            const player = team.players.find(p => p.id === playerId);
            if (!confirm(`Remove ${player.name}?`)) return;

            showLoading();
            try {
                const newPlayers = team.players.filter(p => p.id !== playerId);
                await db.from('teams').update({ players: newPlayers }).eq('id', teamId);
                state.teams = state.teams.map(t => t.id === teamId ? { ...t, players: newPlayers } : t);

                const playerUser = state.users.find(u => u.playerId === playerId);
                if (playerUser && confirm(`Also delete user account?`)) {
                    await db.from('users').delete().eq('id', playerUser.id);
                    state.users = state.users.filter(u => u.id !== playerUser.id);
                }
                render();
            } catch (error) {
                console.error('Error removing player:', error);
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // SCHEDULE FUNCTIONS
        // ============================================
        async function generateSchedule(startDate) {
            if (!startDate) { alert('Please select a start date'); return; }
            if (state.teams.length < 2) { alert('Need at least 2 teams'); return; }
            if (!state.currentSeason) { alert('Please create a season first'); return; }
            if (!state.organization?.id) { alert('No organization loaded'); return; }

            showLoading();
            try {
                const seasonId = state.currentSeason.id;
                const orgId = state.organization.id;
                
                // Clear existing data for this season only
                await db.from('matches').delete().eq('season_id', seasonId);
                await db.from('submissions').delete().eq('season_id', seasonId);
                await db.from('schedule').delete().eq('season_id', seasonId);

                const numTeams = state.teams.length;
                const weeksPerHalf = numTeams % 2 === 1 ? numTeams : numTeams - 1;
                const schedule = generateRoundRobinSchedule(startDate, weeksPerHalf);

                const dbSchedule = schedule.map(s => ({
                    week: s.week, date: s.date, home_team_id: s.homeTeamId,
                    away_team_id: s.awayTeamId, venue: s.venue, is_bye: s.isBye,
                    half: s.half, is_position_night: s.isPositionNight,
                    position_home: s.positionHome, position_away: s.positionAway,
                    season_id: seasonId,
                    org_id: orgId
                }));

                const { data } = await db.from('schedule').insert(dbSchedule).select();

                state.schedule = data.map(s => ({
                    id: s.id, week: s.week, date: s.date, homeTeamId: s.home_team_id,
                    awayTeamId: s.away_team_id, venue: s.venue, isBye: s.is_bye,
                    half: s.half, isPositionNight: s.is_position_night,
                    positionHome: s.position_home, positionAway: s.position_away,
                    seasonId: s.season_id, orgId: s.org_id
                }));

                state.matches = [];
                state.submissions = [];
                state.showGenSchedule = false;

                alert('Schedule generated! ' + (weeksPerHalf * 2 + 2) + ' weeks created.');
                render();
            } catch (error) {
                console.error('Error generating schedule:', error);
                alert('Error generating schedule');
            } finally {
                hideLoading();
            }
        }

        function generateRoundRobinSchedule(startDate, weeksPerHalf) {
            const teams = [...state.teams];
            const numTeams = teams.length;
            const newSchedule = [];
            let currentDate = new Date(startDate);

            // For circle method, we need even number of slots
            // Add BYE placeholder only if odd number of teams
            const teamList = numTeams % 2 === 1 
                ? [...teams, { id: 'BYE_PLACEHOLDER', name: 'BYE', venue: 'BYE WEEK' }]
                : [...teams];
            
            const n = teamList.length;
            const rounds = n - 1;
            const firstHalfHomeAway = {};

            for (let half = 1; half <= 2; half++) {
                const rotating = [...teamList];

                for (let round = 0; round < rounds; round++) {
                    const weekNum = half === 1 ? round + 1 : weeksPerHalf + 2 + round;
                    const weekMatches = [];

                    for (let i = 0; i < n / 2; i++) {
                        const team1 = rotating[i];
                        const team2 = rotating[n - 1 - i];

                        // Skip if same team (should not happen but safeguard)
                        if (team1.id === team2.id) continue;
                        
                        if (team1.id === 'BYE_PLACEHOLDER' && team2.id === 'BYE_PLACEHOLDER') continue;

                        if (team1.id === 'BYE_PLACEHOLDER') {
                            weekMatches.push({ week: weekNum.toString(), date: currentDate.toISOString().split('T')[0], homeTeamId: team2.id, awayTeamId: 'BYE', venue: 'BYE WEEK', isBye: true, half, isPositionNight: false });
                            continue;
                        }

                        if (team2.id === 'BYE_PLACEHOLDER') {
                            weekMatches.push({ week: weekNum.toString(), date: currentDate.toISOString().split('T')[0], homeTeamId: team1.id, awayTeamId: 'BYE', venue: 'BYE WEEK', isBye: true, half, isPositionNight: false });
                            continue;
                        }

                        let home, away;
                        const matchKey = [team1.id, team2.id].sort().join('-');

                        if (half === 1) {
                            home = (round + i) % 2 === 0 ? team1 : team2;
                            away = home === team1 ? team2 : team1;
                            firstHalfHomeAway[matchKey] = home.id;
                        } else {
                            home = firstHalfHomeAway[matchKey] === team1.id ? team2 : team1;
                            away = home === team1 ? team2 : team1;
                        }

                        weekMatches.push({ home, away, matchKey });
                    }

                    const resolved = resolveVenueConflicts(weekMatches, weekNum, currentDate, half, firstHalfHomeAway);
                    newSchedule.push(...resolved);
                    currentDate.setDate(currentDate.getDate() + 7);

                    const last = rotating.pop();
                    rotating.splice(1, 0, last);
                }

                // Position Night
                const posWeek = half === 1 ? weeksPerHalf + 1 : (weeksPerHalf * 2) + 2;
                for (let pos = 0; pos < Math.floor(numTeams / 2); pos++) {
                    newSchedule.push({
                        week: posWeek.toString(), date: currentDate.toISOString().split('T')[0],
                        homeTeamId: `POSITION_${pos * 2 + 1}`, awayTeamId: `POSITION_${pos * 2 + 2}`,
                        venue: 'TBD - Based on Standings', isBye: false, half,
                        isPositionNight: true, positionHome: pos * 2 + 1, positionAway: pos * 2 + 2
                    });
                }

                if (numTeams % 2 === 1) {
                    newSchedule.push({
                        week: posWeek.toString(), date: currentDate.toISOString().split('T')[0],
                        homeTeamId: `POSITION_${numTeams}`, awayTeamId: 'BYE',
                        venue: 'BYE WEEK', isBye: true, half, isPositionNight: true, positionHome: numTeams
                    });
                }

                currentDate.setDate(currentDate.getDate() + 7);
            }

            return newSchedule.sort((a, b) => parseInt(a.week) - parseInt(b.week));
        }

        function resolveVenueConflicts(weekMatches, weekNum, currentDate, half, firstHalfHomeAway) {
            const resolved = [];
            const venuesUsed = new Set();

            weekMatches.filter(m => m.isBye).forEach(m => resolved.push(m));

            for (const match of weekMatches.filter(m => !m.isBye && m.home)) {
                let { home, away, matchKey } = match;
                const homeVenue = (home.venue || '').toLowerCase().trim();
                const awayVenue = (away.venue || '').toLowerCase().trim();

                if (homeVenue && homeVenue !== 'tbd' && venuesUsed.has(homeVenue)) {
                    if (!awayVenue || awayVenue === 'tbd' || !venuesUsed.has(awayVenue)) {
                        [home, away] = [away, home];
                        if (half === 1) firstHalfHomeAway[matchKey] = home.id;
                    }
                }

                const finalVenue = (home.venue || '').toLowerCase().trim();
                if (finalVenue && finalVenue !== 'tbd') venuesUsed.add(finalVenue);

                resolved.push({
                    week: weekNum.toString(), date: currentDate.toISOString().split('T')[0],
                    homeTeamId: home.id, awayTeamId: away.id, venue: home.venue || 'TBD',
                    isBye: false, half, isPositionNight: false
                });
            }

            return resolved;
        }

        async function deleteScheduleMatch(matchId) {
            if (!confirm('Delete this match?')) return;
            showLoading();
            try {
                await db.from('matches').delete().eq('schedule_id', matchId);
                await db.from('submissions').delete().eq('schedule_id', matchId);
                await db.from('schedule').delete().eq('id', matchId);
                state.schedule = state.schedule.filter(m => m.id !== matchId);
                state.submissions = state.submissions.filter(s => s.scheduleId !== matchId);
                state.matches = state.matches.filter(m => m.scheduleId !== matchId);
                render();
            } catch (error) {
                console.error('Error:', error);
            } finally {
                hideLoading();
            }
        }

        async function markAsPlayed(scheduleId) {
            if (!confirm('Mark this match as played? (No scores will be recorded)')) return;
            
            const isAdmin = state.currentUser?.role === 'admin';
            if (!isAdmin) {
                alert('Only admins can mark matches as played');
                return;
            }
            
            const seasonId = state.currentSeason?.id;
            const orgId = state.organization?.id;
            
            if (!seasonId || !orgId) {
                alert('No season or organization selected');
                return;
            }
            
            showLoading();
            try {
                const insertData = {
                    schedule_id: scheduleId,
                    home_score: 0,
                    away_score: 0,
                    matchups: [],
                    approved: true,
                    marked_played: true,
                    season_id: seasonId,
                    org_id: orgId
                };
                
                const { data: matchData, error } = await db.from('matches').insert([insertData]).select().single();
                
                if (error) {
                    console.error('Supabase error:', error);
                    throw error;
                }
                
                state.matches = [...state.matches, {
                    id: matchData.id,
                    scheduleId: matchData.schedule_id,
                    homeScore: matchData.home_score,
                    awayScore: matchData.away_score,
                    matchups: matchData.matchups || [],
                    approved: true,
                    markedPlayed: matchData.marked_played,
                    seasonId: matchData.season_id,
                    orgId: matchData.org_id
                }];
                
                // Clear any pending submissions for this match
                await db.from('submissions').delete().eq('schedule_id', scheduleId);
                state.submissions = state.submissions.filter(s => s.scheduleId !== scheduleId);
                
                render();
                alert('Match marked as played!');
            } catch (error) {
                console.error('Error marking as played:', error);
                alert('Error marking match as played: ' + (error.message || JSON.stringify(error)));
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // MANUAL MATCH CREATION
        // ============================================
        async function addManualMatch() {
            const m = state.manualMatch;
            const isPositionNight = m.isPositionNight || false;
            
            // Validation
            if (!m.week || !m.date) {
                alert('Please fill in week and date');
                return;
            }
            
            if (isPositionNight) {
                // Position night validation
                if (!m.positionHome) {
                    alert('Please select the home position');
                    return;
                }
                if (!m.positionAway && m.positionAway !== 'BYE') {
                    alert('Please select the away position');
                    return;
                }
            } else {
                // Regular match validation
                if (!m.homeTeamId) {
                    alert('Please select a home team');
                    return;
                }
            }
            
            if (!state.currentSeason?.id) {
                alert('Please create or select a season first');
                return;
            }
            
            if (!state.organization?.id) {
                alert('No organization loaded');
                return;
            }
            
            showLoading();
            try {
                let scheduleEntry;
                
                if (isPositionNight) {
                    // Position night match
                    const isBye = m.positionAway === 'BYE';
                    scheduleEntry = {
                        week: m.week,
                        date: m.date,
                        home_team_id: `POSITION_${m.positionHome}`,
                        away_team_id: isBye ? 'BYE' : `POSITION_${m.positionAway}`,
                        venue: m.venue || 'TBD - Based on Standings',
                        is_bye: isBye,
                        half: parseInt(m.half) || 1,
                        is_position_night: true,
                        position_home: parseInt(m.positionHome),
                        position_away: isBye ? null : parseInt(m.positionAway),
                        season_id: state.currentSeason.id,
                        org_id: state.organization.id
                    };
                } else {
                    // Regular match
                    const isBye = m.awayTeamId === 'BYE' || !m.awayTeamId;
                    const homeTeam = (state.teams || []).find(t => t.id === m.homeTeamId);
                    scheduleEntry = {
                        week: m.week,
                        date: m.date,
                        home_team_id: m.homeTeamId,
                        away_team_id: isBye ? 'BYE' : m.awayTeamId,
                        venue: m.venue || homeTeam?.venue || 'TBD',
                        is_bye: isBye,
                        half: parseInt(m.half) || 1,
                        is_position_night: false,
                        season_id: state.currentSeason.id,
                        org_id: state.organization.id
                    };
                }
                
                const { data, error } = await db.from('schedule').insert([scheduleEntry]).select().single();
                
                if (error) throw error;
                
                state.schedule.push({
                    id: data.id,
                    week: data.week,
                    date: data.date,
                    homeTeamId: data.home_team_id,
                    awayTeamId: data.away_team_id,
                    venue: data.venue,
                    isBye: data.is_bye,
                    half: data.half,
                    isPositionNight: data.is_position_night,
                    positionHome: data.position_home,
                    positionAway: data.position_away,
                    seasonId: data.season_id,
                    orgId: data.org_id
                });
                
                // Sort schedule by week
                state.schedule.sort((a, b) => parseInt(a.week) - parseInt(b.week));
                
                // Reset form but preserve the half selection and position night mode
                const currentHalf = m.half;
                const keepPositionNight = m.isPositionNight;
                state.manualMatch = { 
                    week: '', date: '', homeTeamId: '', awayTeamId: '', venue: '', 
                    half: currentHalf, isPositionNight: keepPositionNight, 
                    positionHome: '', positionAway: '' 
                };
                
                // Re-initialize defaults (will set next week/date)
                initManualEntryDefaults();
                
                alert(`${isPositionNight ? 'Position night match' : 'Match'} added successfully!`);
                render();
            } catch (error) {
                console.error('Error adding match:', error);
                alert('Error adding match: ' + error.message);
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // CSV IMPORT
        // ============================================
        async function importScheduleFromCSV(fileInput) {
            const file = fileInput.files[0];
            if (!file) {
                alert('Please select a CSV file');
                return;
            }
            
            if (!state.currentSeason?.id) {
                alert('Please create or select a season first');
                return;
            }
            
            if (!state.organization?.id) {
                alert('No organization loaded');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                showLoading();
                try {
                    const text = e.target.result;
                    const lines = text.split('\n').filter(line => line.trim());
                    
                    if (lines.length < 2) {
                        throw new Error('CSV must have a header row and at least one data row');
                    }
                    
                    // Parse header
                    const header = lines[0].split(',').map(h => h.trim().toLowerCase());
                    
                    // Required columns
                    const weekIdx = header.findIndex(h => h === 'week');
                    const dateIdx = header.findIndex(h => h === 'date');
                    const homeIdx = header.findIndex(h => h === 'home' || h === 'home_team' || h === 'hometeam');
                    const awayIdx = header.findIndex(h => h === 'away' || h === 'away_team' || h === 'awayteam');
                    
                    // Optional columns
                    const venueIdx = header.findIndex(h => h === 'venue' || h === 'location');
                    const halfIdx = header.findIndex(h => h === 'half');
                    
                    if (weekIdx === -1 || dateIdx === -1 || homeIdx === -1) {
                        throw new Error('CSV must have columns: week, date, home (or home_team). Found: ' + header.join(', '));
                    }
                    
                    // Build team name to ID map
                    const teamMap = {};
                    state.teams.forEach(t => {
                        teamMap[t.name.toLowerCase()] = t.id;
                        // Also map without spaces/special chars
                        teamMap[t.name.toLowerCase().replace(/[^a-z0-9]/g, '')] = t.id;
                    });
                    
                    const scheduleEntries = [];
                    const errors = [];
                    
                    for (let i = 1; i < lines.length; i++) {
                        const values = parseCSVLine(lines[i]);
                        if (values.length < Math.max(weekIdx, dateIdx, homeIdx) + 1) continue;
                        
                        const week = values[weekIdx]?.trim();
                        const date = values[dateIdx]?.trim();
                        const homeName = values[homeIdx]?.trim();
                        const awayName = awayIdx !== -1 ? values[awayIdx]?.trim() : '';
                        const venue = venueIdx !== -1 ? values[venueIdx]?.trim() : '';
                        const half = halfIdx !== -1 ? parseInt(values[halfIdx]) || 1 : 1;
                        
                        if (!week || !date || !homeName) {
                            errors.push(`Row ${i + 1}: Missing required fields`);
                            continue;
                        }
                        
                        // Look up team IDs
                        const homeTeamId = teamMap[homeName.toLowerCase()] || teamMap[homeName.toLowerCase().replace(/[^a-z0-9]/g, '')];
                        const isBye = !awayName || awayName.toLowerCase() === 'bye';
                        const awayTeamId = isBye ? 'BYE' : (teamMap[awayName.toLowerCase()] || teamMap[awayName.toLowerCase().replace(/[^a-z0-9]/g, '')]);
                        
                        if (!homeTeamId) {
                            errors.push(`Row ${i + 1}: Home team "${homeName}" not found`);
                            continue;
                        }
                        
                        if (!isBye && !awayTeamId) {
                            errors.push(`Row ${i + 1}: Away team "${awayName}" not found`);
                            continue;
                        }
                        
                        const homeTeam = state.teams.find(t => t.id === homeTeamId);
                        
                        scheduleEntries.push({
                            week: week,
                            date: date,
                            home_team_id: homeTeamId,
                            away_team_id: awayTeamId,
                            venue: venue || homeTeam?.venue || 'TBD',
                            is_bye: isBye,
                            half: half,
                            is_position_night: false,
                            season_id: state.currentSeason.id,
                            org_id: state.organization.id
                        });
                    }
                    
                    if (errors.length > 0) {
                        const proceed = confirm(`Found ${errors.length} error(s):\n\n${errors.slice(0, 5).join('\n')}${errors.length > 5 ? '\n...' : ''}\n\nDo you want to import the ${scheduleEntries.length} valid matches anyway?`);
                        if (!proceed) {
                            hideLoading();
                            return;
                        }
                    }
                    
                    if (scheduleEntries.length === 0) {
                        throw new Error('No valid matches found in CSV');
                    }
                    
                    // Confirm before adding
                    const confirmMsg = `Import ${scheduleEntries.length} matches into ${state.currentSeason.name}?\n\nNote: This will ADD to any existing schedule.`;
                    if (!confirm(confirmMsg)) {
                        hideLoading();
                        return;
                    }
                    
                    // Insert all entries
                    const { data, error } = await db.from('schedule').insert(scheduleEntries).select();
                    
                    if (error) throw error;
                    
                    // Add to state
                    data.forEach(s => {
                        state.schedule.push({
                            id: s.id,
                            week: s.week,
                            date: s.date,
                            homeTeamId: s.home_team_id,
                            awayTeamId: s.away_team_id,
                            venue: s.venue,
                            isBye: s.is_bye,
                            half: s.half,
                            isPositionNight: s.is_position_night,
                            seasonId: s.season_id,
                            orgId: s.org_id
                        });
                    });
                    
                    // Sort schedule by week
                    state.schedule.sort((a, b) => parseInt(a.week) - parseInt(b.week));
                    
                    state.scheduleMode = null;
                    state.autoGenMode = null;
                    
                    alert(`Successfully imported ${data.length} matches!`);
                    render();
                } catch (error) {
                    console.error('Error importing CSV:', error);
                    alert('Error importing CSV: ' + error.message);
                } finally {
                    hideLoading();
                }
            };
            reader.readAsText(file);
        }
        
        // Helper to parse CSV line (handles quoted values)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        // ============================================
        // SCORE SUBMISSION
        // ============================================
        async function submitScores() {
            const sel = state.selectedMatch;
            const team = state.selectedTeam;
            const matchups = state.matchups;
            const seasonId = state.currentSeason?.id;
            const isAdmin = state.currentUser?.role === 'admin';

            // Admin only needs match selected, captains need both match and team
            if (!sel) { alert('Select a match'); return; }
            if (!isAdmin && !team) { alert('Select your team'); return; }
            if (!seasonId) { alert('No season selected'); return; }

            for (let i = 0; i < matchups.length; i++) {
                const m = matchups[i];
                const hg = parseInt(m.homeGames) || 0;
                const ag = parseInt(m.awayGames) || 0;
                if (!m.homePlayer || !m.awayPlayer) { alert(`Game ${i + 1}: Select both players`); return; }
                if (!((hg === 2 && ag <= 1) || (ag === 2 && hg <= 1))) {
                    alert(`Game ${i + 1}: One player must win 2, other 0 or 1`); return;
                }
            }

            const homeScore = matchups.filter(m => parseInt(m.homeGames) > parseInt(m.awayGames)).length;
            const awayScore = matchups.filter(m => parseInt(m.awayGames) > parseInt(m.homeGames)).length;

            if (!state.organization?.id) { alert('No organization loaded'); return; }
            const orgId = state.organization.id;

            showLoading();
            try {
                // ADMIN PATH: Post scores directly without dual-submission
                if (isAdmin) {
                    const insertData = {
                        schedule_id: sel, 
                        home_score: homeScore, 
                        away_score: awayScore,
                        matchups: matchups.map(m => ({ ...m })), 
                        approved: true,
                        season_id: seasonId,
                        org_id: orgId
                    };
                    
                    console.log('Inserting match data:', insertData);
                    
                    const { data: matchData, error } = await db.from('matches').insert([insertData]).select().single();

                    if (error) {
                        console.error('Supabase error:', error);
                        throw error;
                    }

                    state.matches = [...state.matches, {
                        id: matchData.id, 
                        scheduleId: matchData.schedule_id,
                        homeScore: matchData.home_score, 
                        awayScore: matchData.away_score,
                        matchups: matchData.matchups, 
                        approved: true,
                        seasonId: matchData.season_id, 
                        orgId: matchData.org_id
                    }];

                    // Clear any pending submissions for this match
                    await db.from('submissions').delete().eq('schedule_id', sel);
                    state.submissions = state.submissions.filter(s => s.scheduleId !== sel);
                    
                    alert('Scores posted! (Admin)');
                } else {
                    // CAPTAIN PATH: Dual submission workflow
                    if (state.submissions.find(s => s.scheduleId === sel && s.teamId === team)) {
                        alert('Your team already submitted'); 
                        hideLoading();
                        return;
                    }

                    const { data: subData } = await db.from('submissions').insert([{
                        schedule_id: sel, team_id: team, home_score: homeScore,
                        away_score: awayScore, matchups: matchups.map(m => ({ ...m })),
                        season_id: seasonId,
                        org_id: orgId
                    }]).select().single();

                    const newSub = {
                        id: subData.id, scheduleId: subData.schedule_id, teamId: subData.team_id,
                        homeScore: subData.home_score, awayScore: subData.away_score,
                        matchups: subData.matchups, timestamp: subData.created_at,
                        seasonId: subData.season_id, orgId: subData.org_id
                    };

                    state.submissions = [...state.submissions, newSub];

                    const otherSub = state.submissions.find(s => s.scheduleId === sel && s.teamId !== team);

                    if (otherSub) {
                        if (homeScore === otherSub.homeScore && awayScore === otherSub.awayScore) {
                            const { data: matchData } = await db.from('matches').insert([{
                                schedule_id: sel, home_score: homeScore, away_score: awayScore,
                                matchups: newSub.matchups, approved: true,
                                season_id: seasonId,
                                org_id: orgId
                            }]).select().single();

                            state.matches = [...state.matches, {
                                id: matchData.id, scheduleId: matchData.schedule_id,
                                homeScore: matchData.home_score, awayScore: matchData.away_score,
                                matchups: matchData.matchups, approved: true,
                                seasonId: matchData.season_id, orgId: matchData.org_id
                            }];

                            await db.from('submissions').delete().eq('schedule_id', sel);
                            state.submissions = state.submissions.filter(s => s.scheduleId !== sel);
                            alert('Scores match! Approved.');
                        } else {
                            alert('Conflict detected. Needs admin review.');
                        }
                    } else {
                        alert('Submitted! Waiting for other team.');
                    }
                }

                state.selectedMatch = '';
                state.selectedTeam = '';
                state.matchups = Array(5).fill(null).map(() => ({ homePlayer: '', awayPlayer: '', homeGames: '', awayGames: '' }));
                render();
            } catch (error) {
                console.error('Error submitting scores:', error);
                alert('Error submitting scores: ' + (error.message || JSON.stringify(error)));
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // HELPER FUNCTIONS
        // ============================================
        function getOrdinal(n) {
            const s = ['th', 'st', 'nd', 'rd'];
            const v = n % 100;
            return (s[(v - 20) % 10] || s[v] || s[0]);
        }

        function getResolvedPositionTeam(positionId, half) {
            if (!positionId?.startsWith('POSITION_')) return null;
            const position = parseInt(positionId.replace('POSITION_', ''));
            const standings = calcStandingsForHalf(half);
            return position <= standings.length ? standings[position - 1] : null;
        }

        // Consolidated standings calculation
        // upToHalf: null = all matches (full standings), number = only matches up to that half
        function calcStandings(upToHalf = null) {
            const standings = state.teams.map(t => ({ 
                id: t.id, name: t.name, venue: t.venue, 
                wins: 0, losses: 0, gamesWon: 0, gamesLost: 0 
            }));

            state.matches.forEach(match => {
                // Skip marked-as-played matches (no actual scores)
                if (match.markedPlayed) return;
                
                const sched = state.schedule.find(s => s.id === match.scheduleId);
                if (!sched) return;
                
                // If filtering by half, skip matches beyond that half and position nights
                if (upToHalf !== null) {
                    if (sched.half > upToHalf || sched.isPositionNight) return;
                }

                let homeTeamId = sched.homeTeamId, awayTeamId = sched.awayTeamId;
                
                // Resolve position night teams only when calculating full standings
                if (upToHalf === null && sched.isPositionNight) {
                    const rh = getResolvedPositionTeam(sched.homeTeamId, sched.half);
                    const ra = getResolvedPositionTeam(sched.awayTeamId, sched.half);
                    if (rh) homeTeamId = rh.id;
                    if (ra) awayTeamId = ra.id;
                }

                const hIdx = standings.findIndex(s => s.id === homeTeamId);
                const aIdx = standings.findIndex(s => s.id === awayTeamId);
                if (hIdx !== -1 && aIdx !== -1) {
                    standings[hIdx].gamesWon += match.homeScore;
                    standings[hIdx].gamesLost += match.awayScore;
                    standings[aIdx].gamesWon += match.awayScore;
                    standings[aIdx].gamesLost += match.homeScore;
                    if (match.homeScore > match.awayScore) { 
                        standings[hIdx].wins++; 
                        standings[aIdx].losses++; 
                    } else if (match.awayScore > match.homeScore) { 
                        standings[aIdx].wins++; 
                        standings[hIdx].losses++; 
                    }
                }
            });

            // Bye week points - check matchFormat.byePoints setting
            const byeFilter = upToHalf !== null 
                ? s => s.isBye && !s.isPositionNight && s.half <= upToHalf
                : s => s.isBye && !s.isPositionNight;
            
            state.schedule.filter(byeFilter).forEach(s => {
                const byeDate = new Date(s.date);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                if (byeDate <= today) {
                    const byePointsSetting = s.matchFormat?.byePoints || 'win';
                    if (byePointsSetting === 'win') {
                        const idx = standings.findIndex(st => st.id === s.homeTeamId);
                        if (idx !== -1) {
                            standings[idx].wins += 1;
                            const gamesAwarded = s.matchFormat?.matchesPerNight || 5;
                            standings[idx].gamesWon += gamesAwarded;
                        }
                    }
                }
            });

            // Apply manual adjustments from admin
            standings.forEach(team => {
                const adj = state.standingsAdjustments[team.id];
                if (adj) {
                    team.wins += (adj.wins || 0);
                    team.losses += (adj.losses || 0);
                    team.gamesWon += (adj.gamesWon || 0);
                    team.gamesLost += (adj.gamesLost || 0);
                    team.hasAdjustment = true;
                }
            });

            // Sort with head-to-head tiebreaker
            return standings.sort((a, b) => {
                if (b.wins !== a.wins) return b.wins - a.wins;
                if (b.gamesWon !== a.gamesWon) return b.gamesWon - a.gamesWon;
                const h2h = getHeadToHead(a.id, b.id, upToHalf);
                if (h2h !== 0) return h2h;
                return a.name.localeCompare(b.name);
            });
        }
        
        // Backward compatibility alias
        function calcStandingsForHalf(upToHalf) {
            return calcStandings(upToHalf);
        }
        
        // Get head-to-head result between two teams
        // upToHalf: null = all matches, number = only matches up to that half
        // Returns: positive if teamB ahead, negative if teamA ahead (for sort compatibility)
        function getHeadToHead(teamAId, teamBId, upToHalf = null) {
            let teamAWins = 0;
            let teamBWins = 0;
            
            state.matches.forEach(match => {
                if (match.markedPlayed) return;
                
                const sched = state.schedule.find(s => s.id === match.scheduleId);
                if (!sched || sched.isPositionNight) return;
                
                // If filtering by half, skip matches beyond that half
                if (upToHalf !== null && sched.half > upToHalf) return;
                
                // Check if this match is between the two teams
                const isMatchBetween = 
                    (sched.homeTeamId === teamAId && sched.awayTeamId === teamBId) ||
                    (sched.homeTeamId === teamBId && sched.awayTeamId === teamAId);
                
                if (!isMatchBetween) return;
                
                // Determine winner
                if (match.homeScore > match.awayScore) {
                    if (sched.homeTeamId === teamAId) teamAWins++;
                    else teamBWins++;
                } else if (match.awayScore > match.homeScore) {
                    if (sched.awayTeamId === teamAId) teamAWins++;
                    else teamBWins++;
                }
            });
            
            return teamBWins - teamAWins;
        }
        
        // Backward compatibility alias
        function getHeadToHeadForHalf(teamAId, teamBId, upToHalf) {
            return getHeadToHead(teamAId, teamBId, upToHalf);
        }

        function calcPlayerStats() {
            const stats = [];
            state.teams.forEach(team => {
                (team.players || []).forEach(player => {
                    stats.push({ id: player.id, name: player.name, team: team.name, teamId: team.id, matchWins: 0, matchLosses: 0, gamesWon: 0, gamesLost: 0 });
                });
            });

            state.matches.forEach(match => {
                // Skip marked-as-played matches (no player data)
                if (match.markedPlayed) return;
                
                (match.matchups || []).forEach(mu => {
                    const hg = parseInt(mu.homeGames) || 0, ag = parseInt(mu.awayGames) || 0;
                    const hp = stats.find(s => s.id === mu.homePlayer);
                    const ap = stats.find(s => s.id === mu.awayPlayer);
                    if (hp) { 
                        hp.gamesWon += hg; 
                        hp.gamesLost += ag; 
                        if (hg > ag) hp.matchWins++; 
                        else if (ag > hg) hp.matchLosses++; 
                    }
                    if (ap) { 
                        ap.gamesWon += ag; 
                        ap.gamesLost += hg; 
                        if (ag > hg) ap.matchWins++; 
                        else if (hg > ag) ap.matchLosses++; 
                    }
                });
            });

            // Apply manual adjustments from admin
            stats.forEach(player => {
                const adj = state.playerStatsAdjustments[player.id];
                if (adj) {
                    player.matchWins += (adj.matchWins || 0);
                    player.matchLosses += (adj.matchLosses || 0);
                    player.gamesWon += (adj.gamesWon || 0);
                    player.gamesLost += (adj.gamesLost || 0);
                    player.hasAdjustment = true;
                }
            });

            return stats.sort((a, b) => b.matchWins - a.matchWins || b.gamesWon - a.gamesWon);
        }

        // ============================================
        // ADMIN FUNCTIONS
        // ============================================
        async function approveSubmission(scheduleId, subIndex) {
            const subs = state.submissions.filter(s => s.scheduleId === scheduleId);
            const sub = subs[subIndex];

            showLoading();
            try {
                const { data } = await db.from('matches').insert([{
                    schedule_id: scheduleId, home_score: sub.homeScore,
                    away_score: sub.awayScore, matchups: sub.matchups, approved: true,
                    season_id: state.currentSeason?.id,
                    org_id: state.organization?.id
                }]).select().single();

                state.matches = [...state.matches, {
                    id: data.id, scheduleId: data.schedule_id, homeScore: data.home_score,
                    awayScore: data.away_score, matchups: data.matchups, approved: true,
                    seasonId: data.season_id, orgId: data.org_id
                }];

                await db.from('submissions').delete().eq('schedule_id', scheduleId);
                state.submissions = state.submissions.filter(s => s.scheduleId !== scheduleId);
                alert('Approved!');
                render();
            } catch (error) {
                console.error('Error:', error);
            } finally {
                hideLoading();
            }
        }

        async function rejectBoth(scheduleId) {
            if (!confirm('Reject both?')) return;
            showLoading();
            try {
                await db.from('submissions').delete().eq('schedule_id', scheduleId);
                state.submissions = state.submissions.filter(s => s.scheduleId !== scheduleId);
                alert('Rejected. Teams can resubmit.');
                render();
            } catch (error) {
                console.error('Error:', error);
            } finally {
                hideLoading();
            }
        }

        async function clearAllData() {
            if (!confirm('Clear ALL data?')) return;
            if (!confirm('Are you SURE?')) return;

            showLoading();
            try {
                await db.from('matches').delete().neq('id', '00000000-0000-0000-0000-000000000000');
                await db.from('submissions').delete().neq('id', '00000000-0000-0000-0000-000000000000');
                await db.from('schedule').delete().neq('id', '00000000-0000-0000-0000-000000000000');
                await db.from('users').delete().neq('id', '00000000-0000-0000-0000-000000000000');
                await db.from('teams').delete().neq('id', '00000000-0000-0000-0000-000000000000');
                localStorage.removeItem('plm_session');
                location.reload();
            } catch (error) {
                console.error('Error:', error);
            } finally {
                hideLoading();
            }
        }

        // ============================================
        // RENDER FUNCTIONS
        // ============================================
        function renderLoginScreen() {
            // Check if this is first-time setup (no organization loaded)
            const showSetup = !state.organization && state.initialized;
            
            return `
                <div class="min-h-screen bg-gradient-to-br from-slate-900 via-emerald-900 to-teal-900 flex items-center justify-center p-4">
                    <div class="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md border-4 border-emerald-700">
                        <div class="text-center mb-8">
                            <div class="text-6xl mb-4">üèÜ</div>
                            <h1 class="text-4xl font-black text-slate-800 mb-2">Pool League</h1>
                            <p class="text-slate-600" id="form-title">Sign In</p>
                            <p class="text-xs text-emerald-600 mt-2">‚òÅÔ∏è Cloud-Synced</p>
                        </div>
                        
                        <!-- Login Form -->
                        <div id="login-form" class="space-y-4">
                            <input type="email" id="login-email" placeholder="Email" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <input type="password" id="login-password" placeholder="Password" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <div id="login-error" class="hidden bg-red-50 border-2 border-red-200 text-red-700 px-4 py-3 rounded-lg"></div>
                            <button onclick="handleLogin()" class="w-full bg-gradient-to-r from-emerald-600 to-teal-600 text-white font-bold py-4 rounded-lg hover:from-emerald-700 hover:to-teal-700">
                                Sign In
                            </button>
                            <div class="flex justify-between text-sm">
                                <button onclick="showResetForm()" class="text-emerald-600 hover:text-emerald-800">
                                    Forgot Password?
                                </button>
                                <button onclick="showSignupForm()" class="text-blue-600 hover:text-blue-800 font-semibold">
                                    Create Account ‚Üí
                                </button>
                            </div>
                        </div>
                        
                        <!-- Sign Up Form (hidden by default) -->
                        <div id="signup-form" class="space-y-4 hidden">
                            <p class="text-sm text-slate-600 text-center mb-4">Create a new league organization</p>
                            <input type="text" id="signup-org-name" placeholder="Organization / League Name" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <div class="grid grid-cols-2 gap-2">
                                <input type="text" id="signup-firstname" placeholder="First Name" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                                <input type="text" id="signup-lastname" placeholder="Last Name" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            </div>
                            <input type="email" id="signup-email" placeholder="Email" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <input type="tel" id="signup-phone" placeholder="Phone" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <input type="password" id="signup-password" placeholder="Password" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <input type="password" id="signup-password2" placeholder="Confirm Password" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <div id="signup-error" class="hidden bg-red-50 border-2 border-red-200 text-red-700 px-4 py-3 rounded-lg"></div>
                            <button onclick="handleSignup()" class="w-full bg-gradient-to-r from-blue-600 to-indigo-600 text-white font-bold py-4 rounded-lg hover:from-blue-700 hover:to-indigo-700">
                                üöÄ Create Organization
                            </button>
                            <button onclick="showLoginForm()" class="w-full text-sm text-slate-600 hover:text-slate-800 py-2">
                                ‚Üê Back to Login
                            </button>
                        </div>
                        
                        <!-- Reset Password Form (hidden by default) -->
                        <div id="reset-form" class="space-y-4 hidden">
                            <p class="text-sm text-slate-600 text-center mb-4">Enter your email and phone number to reset your password.</p>
                            <input type="email" id="reset-email" placeholder="Email" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <input type="tel" id="reset-phone" placeholder="Phone number on file" class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            <button onclick="handleSelfReset()" class="w-full bg-gradient-to-r from-yellow-500 to-orange-500 text-white font-bold py-4 rounded-lg hover:from-yellow-600 hover:to-orange-600">
                                üîë Reset Password
                            </button>
                            <button onclick="showLoginForm()" class="w-full text-sm text-slate-600 hover:text-slate-800 py-2">
                                ‚Üê Back to Login
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderHeader() {
            // Calculate trial status
            let trialBadge = '';
            if (state.organization) {
                const status = state.organization.subscriptionStatus;
                if (status === 'trial') {
                    const trialEnds = new Date(state.organization.trialEndsAt);
                    const now = new Date();
                    const daysLeft = Math.ceil((trialEnds - now) / (1000 * 60 * 60 * 24));
                    if (daysLeft > 0) {
                        trialBadge = `<a href="pricing.html" class="ml-2 px-2 py-1 bg-yellow-400 text-yellow-900 text-xs rounded-full font-bold hover:bg-yellow-300">
                            ‚è∞ ${daysLeft} days left - Upgrade
                        </a>`;
                    } else {
                        trialBadge = `<a href="pricing.html" class="ml-2 px-2 py-1 bg-red-500 text-white text-xs rounded-full font-bold hover:bg-red-400">
                            ‚ö†Ô∏è Trial Expired - Upgrade Now
                        </a>`;
                    }
                } else if (status === 'active') {
                    const tier = state.organization.subscriptionTier;
                    trialBadge = `<span class="ml-2 px-2 py-1 bg-emerald-400 text-emerald-900 text-xs rounded-full font-bold">
                        ‚úì ${tier.charAt(0).toUpperCase() + tier.slice(1)}
                    </span>`;
                }
            }
            
            // League switcher for multi-league users
            const hasMultipleLeagues = state.userLeagues && state.userLeagues.length > 1;
            const leagueSwitcher = hasMultipleLeagues ? `
                <button onclick="state.showLeagueSelector = true; render();" 
                    class="p-2 bg-white/20 hover:bg-white/30 rounded-lg" title="Switch League">
                    üîÑ
                </button>
            ` : '';
            
            return `
                <header class="bg-gradient-to-r from-emerald-700 via-emerald-600 to-teal-600 text-white shadow-2xl">
                    <div class="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
                        <div>
                            <div class="flex items-center flex-wrap">
                                <h1 class="text-2xl md:text-4xl font-black">üèÜ ${state.leagueName}</h1>
                                ${trialBadge}
                            </div>
                            ${state.seasons.length > 0 ? `
                            <div class="flex items-center gap-2 mt-1">
                                <select onchange="switchSeason(this.value)" class="bg-white/20 text-white text-sm rounded px-2 py-1 border-0">
                                    ${state.seasons.map(s => `
                                        <option value="${s.id}" ${state.currentSeason?.id === s.id ? 'selected' : ''} class="text-gray-800">
                                            ${s.name}${s.isActive ? ' ‚òÖ' : ''}
                                        </option>
                                    `).join('')}
                                </select>
                                ${state.currentSeason?.isActive ? '<span class="text-xs bg-yellow-400 text-yellow-900 px-2 py-0.5 rounded-full font-bold">Active</span>' : '<span class="text-xs bg-white/30 px-2 py-0.5 rounded-full">Archived</span>'}
                            </div>
                            ` : ''}
                        </div>
                        <div class="flex items-center gap-3">
                            <div class="text-right text-sm">
                                <div class="opacity-90">Logged in as</div>
                                <div class="font-bold">${state.currentUser.role === 'admin' ? 'üõ°Ô∏è ' : (state.currentUser.role === 'captain' ? '¬©Ô∏è ' : 'üë§ ')}${getUserDisplayName(state.currentUser)}</div>
                            </div>
                            ${leagueSwitcher}
                            <button onclick="logout()" class="p-2 bg-white/20 hover:bg-white/30 rounded-lg">üö™</button>
                        </div>
                    </div>
                </header>
            `;
        }

        function renderNav() {
            const isAdmin = state.currentUser.role === 'admin';
            const isCaptain = state.currentUser.role === 'captain';
            const isPlayer = state.currentUser.role === 'player';
            
            // Players: view-only access to schedule, standings, history, their team
            // Captains: can submit scores, manage their team roster
            // Admins: full access
            const tabs = [
                { id: 'schedule', label: 'üìÖ Schedule' },
                ...(!isPlayer ? [{ id: 'submit', label: 'üìù Submit' }] : []),
                { id: 'standings', label: 'üèÜ Standings' },
                { id: 'players', label: 'üë§ Players' },
                { id: 'history', label: 'üìú History' },
                { id: 'teams', label: 'üè† Teams' },
                ...(!isPlayer ? [{ id: 'users', label: 'üë• Users' }] : []),
                ...(isAdmin ? [{ id: 'admin', label: 'üõ°Ô∏è Admin' }, { id: 'settings', label: '‚öôÔ∏è Settings' }] : [])
            ];

            return `
                <nav class="bg-white shadow-md border-b-2 border-emerald-100">
                    <div class="max-w-7xl mx-auto px-4 flex gap-1 overflow-x-auto tab-scroll">
                        ${tabs.map(tab => `
                            <button onclick="window.state.activeTab='${tab.id}'; window.render();"
                                class="px-4 py-3 font-semibold transition-all border-b-4 whitespace-nowrap text-sm ${
                                    state.activeTab === tab.id
                                        ? 'text-emerald-700 border-emerald-700 bg-emerald-50'
                                        : 'text-gray-600 border-transparent hover:text-emerald-600'
                                }">
                                ${tab.label}
                            </button>
                        `).join('')}
                    </div>
                </nav>
            `;
        }

        function renderSchedule() {
            const isAdmin = state.currentUser.role === 'admin';
            const isCaptain = state.currentUser.role === 'captain';
            const isPlayer = !isAdmin && !isCaptain;
            const myTeamId = state.currentUser.teamId;
            const myTeam = state.teams.find(t => t.id === myTeamId);
            
            const completedMatches = state.matches.length;
            const totalMatches = state.schedule.filter(s => !s.isBye).length;
            
            // If admin is in schedule creation mode, show that interface
            if (isAdmin && state.scheduleMode) {
                return renderScheduleCreation();
            }
            
            // For players, filter schedule to only their team's matches (unless showing full)
            let displaySchedule = [...state.schedule];
            if (isPlayer && myTeamId && !state.showFullSchedule) {
                displaySchedule = state.schedule.filter(match => {
                    if (match.isPositionNight) {
                        // For position nights, check if resolved teams include player's team
                        const rh = getResolvedPositionTeam(match.homeTeamId, match.half);
                        const ra = getResolvedPositionTeam(match.awayTeamId, match.half);
                        return rh?.id === myTeamId || ra?.id === myTeamId;
                    }
                    return match.homeTeamId === myTeamId || match.awayTeamId === myTeamId;
                });
            }
            
            // Sort by week ascending (Week 1 at top)
            displaySchedule.sort((a, b) => parseInt(a.week) - parseInt(b.week));
            
            // Find next upcoming game (not completed, not a bye, earliest date)
            const today = new Date().toISOString().split('T')[0];
            const nextGame = displaySchedule.find(match => {
                if (match.isBye) return false;
                const hasResult = state.matches.find(m => m.scheduleId === match.id);
                if (hasResult) return false;
                return true; // First incomplete non-bye match
            });
            
            // Helper to format next game display
            const formatNextGame = (match) => {
                if (!match) return null;
                
                let homeTeam, awayTeam, venue;
                if (match.isPositionNight) {
                    const rh = getResolvedPositionTeam(match.homeTeamId, match.half);
                    const ra = getResolvedPositionTeam(match.awayTeamId, match.half);
                    homeTeam = rh ? `#${match.positionHome} ${rh.name}` : `${match.positionHome}${getOrdinal(match.positionHome)} Place`;
                    awayTeam = ra ? `#${match.positionAway} ${ra.name}` : `${match.positionAway}${getOrdinal(match.positionAway)} Place`;
                    venue = rh?.venue || 'TBD';
                } else {
                    const home = state.teams.find(t => t.id === match.homeTeamId);
                    const away = state.teams.find(t => t.id === match.awayTeamId);
                    homeTeam = home?.name || '?';
                    awayTeam = away?.name || '?';
                    venue = match.venue || home?.venue || 'TBD';
                }
                
                return { homeTeam, awayTeam, venue, date: match.date, week: match.week, isPositionNight: match.isPositionNight };
            };
            
            const nextGameInfo = formatNextGame(nextGame);
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6">
                        <h2 class="text-3xl font-black">üìÖ ${isPlayer && myTeam ? myTeam.name + ' Schedule' : 'League Schedule'}</h2>
                        <p class="mt-1 opacity-90">${isPlayer ? 'View your team\'s upcoming matches' : 'Manage seasons and view match schedules'}</p>
                    </div>

                    <!-- Next Game Highlight -->
                    ${nextGameInfo ? `
                    <div class="bg-gradient-to-r from-amber-50 to-orange-50 rounded-xl shadow-lg p-5 border-2 border-amber-300">
                        <div class="flex items-center gap-2 mb-3">
                            <span class="text-2xl">üé±</span>
                            <h3 class="font-bold text-amber-800">Next Match${nextGameInfo.isPositionNight ? ' (Position Night)' : ''}</h3>
                            <span class="ml-auto px-3 py-1 bg-amber-200 text-amber-900 rounded-full text-sm font-bold">Week ${nextGameInfo.week}</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <div class="flex-1">
                                <div class="text-2xl font-black text-slate-800 mb-1">
                                    ${nextGameInfo.awayTeam} <span class="text-amber-600">@</span> ${nextGameInfo.homeTeam}
                                </div>
                                <div class="text-sm text-slate-600">
                                    üìç ${nextGameInfo.venue} ‚Ä¢ üìÖ ${new Date(nextGameInfo.date + 'T12:00:00').toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' })}
                                </div>
                            </div>
                        </div>
                    </div>
                    ` : displaySchedule.length > 0 ? `
                    <div class="bg-green-50 rounded-xl shadow-lg p-5 border-2 border-green-300 text-center">
                        <span class="text-2xl">üèÜ</span>
                        <h3 class="font-bold text-green-800 mt-2">Season Complete!</h3>
                        <p class="text-sm text-green-600">All matches have been played.</p>
                    </div>
                    ` : ''}

                    ${!isPlayer ? `
                    <!-- Season Management Section (Admin/Captain Only) -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-xl font-bold flex items-center gap-2">
                                üìÜ Seasons
                                <span class="text-sm font-normal text-slate-500">(${state.seasons.length} total)</span>
                            </h3>
                            ${isAdmin ? `
                            <button onclick="window.state.showManageSeasons = !window.state.showManageSeasons; window.render();" 
                                class="text-sm text-emerald-600 hover:text-emerald-800 font-semibold">
                                ${state.showManageSeasons ? '‚ñº Hide' : '‚ñ∂ Manage'}
                            </button>
                            ` : ''}
                        </div>
                        
                        <!-- Current Season Display -->
                        ${state.currentSeason ? `
                        <div class="flex items-center gap-4 p-4 bg-emerald-50 rounded-lg border-2 border-emerald-200">
                            <div class="text-3xl">üèÜ</div>
                            <div class="flex-1">
                                <div class="font-bold text-lg text-emerald-800">${state.currentSeason.name}</div>
                                <div class="text-sm text-emerald-600">
                                    ${state.currentSeason.isActive ? '‚òÖ Active Season' : 'Archived'} 
                                    ‚Ä¢ ${completedMatches}/${totalMatches} matches complete
                                </div>
                            </div>
                            <select onchange="switchSeason(this.value)" class="px-3 py-2 border-2 border-emerald-300 rounded-lg bg-white text-sm">
                                ${state.seasons.map(s => `
                                    <option value="${s.id}" ${state.currentSeason?.id === s.id ? 'selected' : ''}>
                                        ${s.name}${s.isActive ? ' ‚òÖ' : ''}
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        ` : `
                        <div class="p-4 bg-yellow-50 rounded-lg border-2 border-yellow-200 text-center">
                            <p class="text-yellow-800">No seasons created yet. ${isAdmin ? 'Create one below to get started!' : 'Contact admin to create a season.'}</p>
                        </div>
                        `}
                        
                        <!-- Season Management (Admin Only) -->
                        ${isAdmin && state.showManageSeasons ? `
                        <div class="mt-4 border-t pt-4">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="font-semibold">All Seasons</h4>
                                <label class="flex items-center gap-2 text-sm text-slate-600">
                                    <input type="checkbox" 
                                        ${state.showArchivedSeasons ? 'checked' : ''} 
                                        onchange="window.state.showArchivedSeasons = this.checked; window.render();"
                                        class="rounded">
                                    Show archived
                                </label>
                            </div>
                            <div class="space-y-2 max-h-48 overflow-y-auto">
                                ${state.seasons.filter(s => state.showArchivedSeasons || !s.isArchived).length === 0 ? `
                                    <p class="text-slate-500 text-sm">No seasons yet</p>
                                ` : state.seasons.filter(s => state.showArchivedSeasons || !s.isArchived).map(s => {
                                    const isArchived = s.isArchived;
                                    return `
                                    <div class="flex items-center justify-between p-3 rounded-lg ${s.id === state.currentSeason?.id ? 'bg-emerald-50 border border-emerald-200' : isArchived ? 'bg-slate-100 opacity-60' : 'bg-slate-50'}">
                                        <div class="flex items-center gap-3">
                                            <span class="text-lg">${isArchived ? 'üì¶' : s.isActive ? 'üèÜ' : 'üìÅ'}</span>
                                            <div>
                                                <div class="font-semibold">${s.name}</div>
                                                <div class="text-xs text-slate-500">
                                                    ${isArchived ? 'üì¶ Archived' : s.isActive ? '‚òÖ Active' : 'Inactive'}
                                                    ${s.id === state.currentSeason?.id ? ' ‚Ä¢ Currently Viewing' : ''}
                                                </div>
                                            </div>
                                        </div>
                                        <div class="flex items-center gap-2">
                                            ${isArchived ? `
                                                <button onclick="unarchiveSeason('${s.id}')" class="px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs hover:bg-blue-200">
                                                    Restore
                                                </button>
                                            ` : `
                                                ${!s.isActive ? `
                                                    <button onclick="setActiveSeason('${s.id}')" class="px-2 py-1 bg-emerald-100 text-emerald-700 rounded text-xs hover:bg-emerald-200">
                                                        Set Active
                                                    </button>
                                                ` : ''}
                                            `}
                                            <button onclick="confirmDeleteSeason('${s.id}', '${s.name.replace(/'/g, "\\'")}')" 
                                                class="px-2 py-1 bg-red-100 text-red-700 rounded text-xs hover:bg-red-200"
                                                title="${isArchived ? 'Delete archived season' : 'Delete or archive season'}">
                                                üóëÔ∏è
                                            </button>
                                        </div>
                                    </div>
                                `}).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    ` : `
                    <!-- Player View: Team Info Card -->
                    ${myTeam ? `
                    <div class="bg-white rounded-xl shadow-lg p-4">
                        <div class="flex items-center gap-4">
                            <div class="text-3xl">üé±</div>
                            <div class="flex-1">
                                <div class="font-bold text-lg">${myTeam.name}</div>
                                <div class="text-sm text-slate-600">
                                    ${state.currentSeason?.name || 'Current Season'} 
                                    ‚Ä¢ ${displaySchedule.filter(s => !s.isBye).length} matches
                                </div>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                    `}

                    <!-- Schedule Table -->
                    ${displaySchedule.length === 0 ? `
                        <div class="bg-white rounded-xl shadow-lg p-12 text-center">
                            <div class="text-6xl mb-4">üìÖ</div>
                            <h3 class="text-2xl font-bold text-slate-800 mb-2">No Schedule Yet</h3>
                            <p class="text-slate-600 mb-6">${isAdmin ? 'Create a schedule to get started' : 'Check back later for the schedule'}</p>
                            ${isAdmin ? `
                            <button onclick="window.state.scheduleMode = 'choose'; window.render();" 
                                class="px-6 py-3 bg-emerald-600 text-white font-bold rounded-lg hover:bg-emerald-700">
                                ‚ûï Create Schedule
                            </button>
                            ` : ''}
                        </div>
                    ` : `
                        <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                            <div class="bg-slate-50 px-4 py-3 border-b flex items-center justify-between">
                                <h3 class="font-bold">${isPlayer && !state.showFullSchedule ? (myTeam?.name || 'Your') + ' Matches' : (state.currentSeason?.name || 'Schedule')}</h3>
                                <div class="flex items-center gap-4">
                                    <div class="text-sm text-slate-600">
                                        ${displaySchedule.filter(s => !s.isBye && !s.isPositionNight).length} matches 
                                        ‚Ä¢ ${[...new Set(displaySchedule.map(s => s.week))].length} weeks
                                    </div>
                                    ${isAdmin ? `
                                    <button onclick="window.state.scheduleMode = 'choose'; window.render();" 
                                        class="px-3 py-1 bg-emerald-100 text-emerald-700 rounded text-sm font-semibold hover:bg-emerald-200">
                                        ‚ûï Add Matches
                                    </button>
                                    ` : ''}
                                </div>
                            </div>
                            <div class="overflow-x-auto">
                                <table class="w-full">
                                    <thead class="bg-slate-100">
                                        <tr>
                                            <th class="px-4 py-3 text-left text-sm font-bold">Week</th>
                                            <th class="px-4 py-3 text-left text-sm font-bold">Half</th>
                                            <th class="px-4 py-3 text-left text-sm font-bold">Date</th>
                                            <th class="px-4 py-3 text-left text-sm font-bold">Matchup</th>
                                            <th class="px-4 py-3 text-left text-sm font-bold">Venue</th>
                                            <th class="px-4 py-3 text-left text-sm font-bold">Status</th>
                                            ${isAdmin ? '<th class="px-4 py-3 text-left text-sm font-bold"></th>' : ''}
                                        </tr>
                                    </thead>
                                    <tbody class="divide-y">
                                        ${displaySchedule.map(match => {
                                            let matchupDisplay, venueDisplay;

                                            if (match.isPositionNight) {
                                                const rh = getResolvedPositionTeam(match.homeTeamId, match.half);
                                                const ra = getResolvedPositionTeam(match.awayTeamId, match.half);
                                                if (match.isBye) {
                                                    matchupDisplay = `<span class="text-purple-600">üèñÔ∏è ${rh?.name || match.positionHome + getOrdinal(match.positionHome) + ' Place'} - BYE</span>`;
                                                    venueDisplay = '-';
                                                } else if (rh && ra) {
                                                    matchupDisplay = `<span class="text-purple-700 font-bold">üèÜ #${match.positionAway} ${ra.name} @ #${match.positionHome} ${rh.name}</span>`;
                                                    venueDisplay = rh.venue || 'TBD';
                                                } else {
                                                    matchupDisplay = `<span class="text-purple-500 italic">üèÜ ${match.positionAway}${getOrdinal(match.positionAway)} @ ${match.positionHome}${getOrdinal(match.positionHome)}</span>`;
                                                    venueDisplay = 'TBD';
                                                }
                                            } else {
                                                const home = state.teams.find(t => t.id === match.homeTeamId);
                                                const away = state.teams.find(t => t.id === match.awayTeamId);
                                                if (match.isBye) {
                                                    matchupDisplay = `<span class="text-blue-600">üèñÔ∏è ${home?.name || '?'} - BYE</span>`;
                                                    venueDisplay = '-';
                                                } else {
                                                    // Highlight player's team
                                                    const homeHighlight = isPlayer && home?.id === myTeamId ? 'font-bold text-emerald-700' : '';
                                                    const awayHighlight = isPlayer && away?.id === myTeamId ? 'font-bold text-emerald-700' : '';
                                                    matchupDisplay = `<span class="${awayHighlight}">${away?.name || '?'}</span> @ <span class="${homeHighlight}">${home?.name || '?'}</span>`;
                                                    venueDisplay = match.venue || 'TBD';
                                                }
                                            }

                                            const result = state.matches.find(m => m.scheduleId === match.id);
                                            const subs = state.submissions.filter(s => s.scheduleId === match.id);

                                            let status = '<span class="px-2 py-1 bg-gray-100 text-gray-600 rounded-full text-xs">Pending</span>';
                                            if (match.isBye) status = '<span class="px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs">BYE</span>';
                                            else if (result && result.markedPlayed) status = '<span class="px-2 py-1 bg-slate-200 text-slate-700 rounded-full text-xs font-bold">‚úì Played</span>';
                                            else if (result) status = `<span class="px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs font-bold">${result.awayScore}-${result.homeScore}</span>`;
                                            else if (subs.length === 2) status = '<span class="px-2 py-1 bg-yellow-100 text-yellow-800 rounded-full text-xs">‚ö†Ô∏è Conflict</span>';
                                            else if (subs.length === 1) status = '<span class="px-2 py-1 bg-blue-100 text-blue-800 rounded-full text-xs">1/2</span>';

                                            const halfDisplay = match.isPositionNight
                                                ? '<span class="px-2 py-1 bg-purple-200 text-purple-900 rounded text-xs font-bold">Position</span>'
                                                : `<span class="px-2 py-1 ${match.half === 1 ? 'bg-purple-100 text-purple-800' : 'bg-orange-100 text-orange-800'} rounded text-xs">${match.half === 1 ? '1st' : '2nd'}</span>`;

                                            const rowClass = match.isPositionNight ? 'bg-purple-50' : (match.isBye ? 'bg-blue-50' : '');
                                            
                                            // Show Mark as Played button for admin on pending non-bye matches
                                            const showMarkPlayed = isAdmin && !match.isBye && !result;

                                            return `
                                                <tr class="${rowClass} hover:bg-slate-50">
                                                    <td class="px-4 py-3 font-bold">${match.week}</td>
                                                    <td class="px-4 py-3">${halfDisplay}</td>
                                                    <td class="px-4 py-3">${match.date}</td>
                                                    <td class="px-4 py-3">${matchupDisplay}</td>
                                                    <td class="px-4 py-3 text-slate-600">${venueDisplay}</td>
                                                    <td class="px-4 py-3">${status}</td>
                                                    ${isAdmin ? `
                                                    <td class="px-4 py-3 whitespace-nowrap">
                                                        ${showMarkPlayed ? `<button onclick="markAsPlayed('${match.id}')" class="text-slate-600 hover:text-slate-800 text-xs mr-2" title="Mark as played without scores">‚úì Played</button>` : ''}
                                                        <button onclick="deleteScheduleMatch('${match.id}')" class="text-red-600 hover:text-red-800 text-sm">üóëÔ∏è</button>
                                                    </td>
                                                    ` : ''}
                                                </tr>
                                            `;
                                        }).join('')}
                                    </tbody>
                                </table>
                            </div>
                            
                            ${isPlayer ? `
                            <!-- View Full Schedule Link for Players -->
                            <div class="px-4 py-3 bg-slate-50 border-t text-center">
                                <button onclick="window.state.showFullSchedule = !window.state.showFullSchedule; window.render();" 
                                    class="text-emerald-600 hover:text-emerald-800 font-semibold text-sm">
                                    ${state.showFullSchedule ? 'üë§ Show Only My Matches' : 'üìÖ View Full Season Schedule'}
                                </button>
                            </div>
                            ` : ''}
                        </div>
                    `}
                </div>
            `;
        }
        
        // Schedule creation interface with choice screen
        function renderScheduleCreation() {
            const mode = state.scheduleMode;
            const autoMode = state.autoGenMode;
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-xl shadow-lg p-6">
                        <div class="flex items-center justify-between">
                            <div>
                                <h2 class="text-3xl font-black">üìÖ Create Schedule</h2>
                                <p class="mt-1 opacity-90">Add matches to your season</p>
                            </div>
                            <button onclick="window.state.scheduleMode = null; window.state.autoGenMode = null; window.render();" 
                                class="px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg font-semibold">
                                ‚Üê Back to Schedule
                            </button>
                        </div>
                    </div>
                    
                    ${!state.currentSeason ? `
                    <div class="bg-yellow-50 border-2 border-yellow-300 rounded-xl p-6 text-center">
                        <div class="text-4xl mb-3">‚ö†Ô∏è</div>
                        <h3 class="font-bold text-yellow-800 text-lg">Create a Season First</h3>
                        <p class="text-yellow-700 mt-2">You need to create a season before adding matches.</p>
                        <div class="mt-4 flex gap-2 justify-center items-center">
                            <input type="text" id="quick-season-name" placeholder="Season name (e.g., Spring 2025)" 
                                class="px-4 py-2 border-2 border-yellow-400 rounded-lg">
                            <button onclick="quickCreateSeason()" class="px-4 py-2 bg-yellow-500 text-white font-bold rounded-lg hover:bg-yellow-600">
                                Create Season
                            </button>
                        </div>
                    </div>
                    ` : mode === 'choose' ? `
                    <!-- Choice Screen -->
                    <div class="bg-white rounded-xl shadow-lg p-8">
                        <h3 class="text-2xl font-bold text-center mb-8">How would you like to create your schedule?</h3>
                        
                        <div class="grid md:grid-cols-2 gap-6 max-w-4xl mx-auto">
                            <!-- Manual Option -->
                            <button onclick="window.state.scheduleMode = 'manual'; window.initManualEntryDefaults(); window.render();" 
                                class="p-8 border-2 border-slate-200 rounded-xl hover:border-emerald-400 hover:bg-emerald-50 transition-all text-left group">
                                <div class="text-5xl mb-4">‚úèÔ∏è</div>
                                <h4 class="text-xl font-bold text-slate-800 group-hover:text-emerald-700">Manual Entry</h4>
                                <p class="text-slate-600 mt-2">Add matches one at a time. Full control over every detail.</p>
                                <ul class="mt-4 text-sm text-slate-500 space-y-1">
                                    <li>‚Ä¢ Choose specific dates and times</li>
                                    <li>‚Ä¢ Set custom matchups</li>
                                    <li>‚Ä¢ Add byes as needed</li>
                                </ul>
                            </button>
                            
                            <!-- Auto Generate Option -->
                            <button onclick="window.state.scheduleMode = 'auto'; window.render();" 
                                class="p-8 border-2 border-slate-200 rounded-xl hover:border-blue-400 hover:bg-blue-50 transition-all text-left group">
                                <div class="text-5xl mb-4">üîÑ</div>
                                <h4 class="text-xl font-bold text-slate-800 group-hover:text-blue-700">Auto Generate</h4>
                                <p class="text-slate-600 mt-2">Let the system create your schedule automatically.</p>
                                <ul class="mt-4 text-sm text-slate-500 space-y-1">
                                    <li>‚Ä¢ Round-robin algorithm</li>
                                    <li>‚Ä¢ Import from CSV file</li>
                                    <li>‚Ä¢ More options coming soon</li>
                                </ul>
                            </button>
                        </div>
                    </div>
                    ` : mode === 'manual' ? renderManualScheduleEntry() : mode === 'auto' ? renderAutoGenerateOptions() : ''}
                </div>
            `;
        }
        
        // Manual schedule entry form
        function renderManualScheduleEntry() {
            const m = state.manualMatch;
            const mode = state.manualEntryMode;
            // Venues can be either strings or objects with .name property
            const venueNames = (state.venues || []).map(v => typeof v === 'string' ? v : v.name).filter(v => v);
            const teamVenues = (state.teams || []).map(t => t.venue).filter(v => v && v.trim());
            const allVenues = [...new Set([...venueNames, ...teamVenues])].filter(v => v).sort((a, b) => a.localeCompare(b));
            
            return `
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-6">
                        <h3 class="text-xl font-bold">‚úèÔ∏è Manual Schedule Entry</h3>
                        <button onclick="window.state.scheduleMode = 'choose'; window.render();" 
                            class="text-sm text-slate-600 hover:text-slate-800">‚Üê Back to options</button>
                    </div>
                    
                    <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mb-6">
                        <p class="text-emerald-800 text-sm">
                            <strong>Adding to:</strong> ${state.currentSeason?.name || 'No season selected'}
                        </p>
                    </div>
                    
                    <!-- Mode Toggle -->
                    <div class="flex gap-2 mb-6">
                        <button onclick="window.state.manualEntryMode = 'single'; window.render();" 
                            class="flex-1 py-3 rounded-lg font-bold transition-all ${mode === 'single' 
                                ? 'bg-emerald-600 text-white' 
                                : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}">
                            ‚ûï Single Match
                        </button>
                        <button onclick="window.state.manualEntryMode = 'week'; window.initWeekMatches(); window.render();" 
                            class="flex-1 py-3 rounded-lg font-bold transition-all ${mode === 'week' 
                                ? 'bg-blue-600 text-white' 
                                : 'bg-slate-100 text-slate-600 hover:bg-slate-200'}">
                            üìÖ Full Week
                        </button>
                    </div>
                    
                    <!-- Play Days Setting -->
                    <div class="mb-6 p-4 bg-slate-50 rounded-lg border">
                        <label class="block text-sm font-bold text-slate-700 mb-2">üìÖ League Play Days:</label>
                        <div class="flex flex-wrap gap-2">
                            ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day, i) => `
                                <button onclick="window.toggleManualPlayDay(${i})" 
                                    class="px-3 py-1 rounded-full text-sm font-semibold transition-all ${
                                        state.playDays.includes(i) 
                                            ? 'bg-emerald-600 text-white' 
                                            : 'bg-slate-200 text-slate-600 hover:bg-slate-300'
                                    }">
                                    ${day}
                                </button>
                            `).join('')}
                        </div>
                        <p class="text-xs text-slate-500 mt-2">Selected days are used for auto-calculating dates.</p>
                    </div>
                    
                    <!-- Common Week/Date/Half fields -->
                    <div class="grid md:grid-cols-3 gap-4 mb-6 p-4 bg-slate-50 rounded-lg border">
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-1">Week Number *</label>
                            <div class="flex gap-2">
                                <input type="text" id="manual-week" value="${m.week}" 
                                    onchange="window.state.manualMatch.week = this.value;"
                                    placeholder="e.g., 1" 
                                    class="flex-1 px-4 py-2 border-2 border-slate-300 rounded-lg focus:border-emerald-500 bg-white">
                                <button onclick="window.advanceToNextWeek()" 
                                    class="px-3 py-2 bg-emerald-100 text-emerald-700 rounded-lg hover:bg-emerald-200 text-sm font-bold"
                                    title="Advance to next week">+1</button>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-1">Date *</label>
                            <input type="date" id="manual-date" value="${m.date}"
                                onchange="window.state.manualMatch.date = this.value;"
                                class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg focus:border-emerald-500 bg-white">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-1">Half</label>
                            <select id="manual-half" 
                                onchange="window.state.manualMatch.half = this.value;"
                                class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg focus:border-emerald-500 bg-white">
                                <option value="1" ${m.half === '1' ? 'selected' : ''}>1st Half</option>
                                <option value="2" ${m.half === '2' ? 'selected' : ''}>2nd Half</option>
                            </select>
                        </div>
                    </div>
                    
                    ${mode === 'single' ? renderSingleMatchEntry(m, allVenues) : renderWeekEntry(allVenues)}
                </div>
                
                <!-- Recently Added Preview -->
                ${state.schedule.length > 0 ? `
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <h4 class="font-bold mb-4">Current Schedule (${state.schedule.length} matches)</h4>
                    <div class="max-h-64 overflow-y-auto">
                        <table class="w-full text-sm">
                            <thead class="bg-slate-50 sticky top-0">
                                <tr>
                                    <th class="px-3 py-2 text-left">Week</th>
                                    <th class="px-3 py-2 text-left">Date</th>
                                    <th class="px-3 py-2 text-left">Matchup</th>
                                    <th class="px-3 py-2 text-left">Venue</th>
                                    <th class="px-3 py-2"></th>
                                </tr>
                            </thead>
                            <tbody class="divide-y">
                                ${state.schedule.slice(-10).reverse().map(s => {
                                    const home = state.teams.find(t => t.id === s.homeTeamId);
                                    const away = state.teams.find(t => t.id === s.awayTeamId);
                                    return `
                                        <tr class="hover:bg-slate-50">
                                            <td class="px-3 py-2">${s.week}</td>
                                            <td class="px-3 py-2">${s.date}</td>
                                            <td class="px-3 py-2">${s.isBye ? home?.name + ' - BYE' : (away?.name || '?') + ' @ ' + (home?.name || '?')}</td>
                                            <td class="px-3 py-2 text-slate-600">${s.venue || '-'}</td>
                                            <td class="px-3 py-2">
                                                <button onclick="deleteScheduleMatch('${s.id}')" class="text-red-500 hover:text-red-700">üóëÔ∏è</button>
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
                ` : ''}
            `;
        }
        
        // Single match entry form
        function renderSingleMatchEntry(m, allVenues) {
            const sortedTeams = [...(state.teams || [])].sort((a, b) => a.name.localeCompare(b.name));
            const numTeams = sortedTeams.length;
            const isPositionNight = m.isPositionNight || false;
            
            // Calculate position night matchups
            const numPositionMatches = Math.floor(numTeams / 2);
            const hasPositionBye = numTeams % 2 === 1;
            
            return `
                <!-- Match Type Toggle -->
                <div class="mb-6 p-4 bg-slate-50 rounded-lg border">
                    <label class="block text-sm font-bold text-slate-700 mb-2">Match Type:</label>
                    <div class="flex gap-2">
                        <button onclick="window.state.manualMatch.isPositionNight = false; window.state.manualMatch.positionHome = ''; window.state.manualMatch.positionAway = ''; window.render();" 
                            class="flex-1 py-2 rounded-lg font-semibold transition-all ${!isPositionNight 
                                ? 'bg-emerald-600 text-white' 
                                : 'bg-slate-200 text-slate-600 hover:bg-slate-300'}">
                            üé± Regular Match
                        </button>
                        <button onclick="window.state.manualMatch.isPositionNight = true; window.state.manualMatch.homeTeamId = ''; window.state.manualMatch.awayTeamId = ''; window.state.manualMatch.venue = 'TBD - Based on Standings'; window.render();" 
                            class="flex-1 py-2 rounded-lg font-semibold transition-all ${isPositionNight 
                                ? 'bg-purple-600 text-white' 
                                : 'bg-slate-200 text-slate-600 hover:bg-slate-300'}">
                            üèÜ Position Night
                        </button>
                    </div>
                </div>
                
                ${isPositionNight ? `
                <!-- Position Night Batch Entry -->
                <div class="bg-purple-50 border-2 border-purple-200 rounded-lg p-4 mb-6">
                    <h4 class="font-bold text-purple-800 mb-2">üèÜ Position Night Matches</h4>
                    <p class="text-purple-700 text-sm mb-4">
                        Teams are matched by standings: 1st vs 2nd, 3rd vs 4th, etc. 
                        Matches will be added for Week ${m.week || '?'} on ${m.date || '(select date)'}.
                    </p>
                    
                    <div class="bg-white rounded-lg p-4 mb-4">
                        <h5 class="font-semibold text-purple-800 mb-3">Matches to be created (${numPositionMatches}${hasPositionBye ? ' + 1 bye' : ''}):</h5>
                        <div class="space-y-2">
                            ${Array.from({length: numPositionMatches}, (_, i) => {
                                const pos1 = i * 2 + 1;
                                const pos2 = i * 2 + 2;
                                return `
                                    <div class="flex items-center gap-2 text-sm">
                                        <span class="w-6 h-6 bg-purple-100 rounded-full flex items-center justify-center text-purple-700 font-bold">${i + 1}</span>
                                        <span class="text-purple-700">${pos2}${getOrdinal(pos2)} Place</span>
                                        <span class="text-slate-400">@</span>
                                        <span class="text-purple-700 font-semibold">${pos1}${getOrdinal(pos1)} Place</span>
                                        <span class="text-slate-400 text-xs">(${pos1}${getOrdinal(pos1)} hosts)</span>
                                    </div>
                                `;
                            }).join('')}
                            ${hasPositionBye ? `
                                <div class="flex items-center gap-2 text-sm text-blue-600">
                                    <span class="w-6 h-6 bg-blue-100 rounded-full flex items-center justify-center text-blue-700 font-bold">üèñÔ∏è</span>
                                    <span>${numTeams}${getOrdinal(numTeams)} Place - BYE</span>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                    
                    <p class="text-xs text-purple-600 mb-2">
                        ‚ÑπÔ∏è Venue will be determined by home team's standings position at game time.
                    </p>
                </div>
                
                <div class="flex gap-4">
                    <button onclick="window.addPositionNightMatches()" 
                        class="flex-1 py-3 bg-purple-600 hover:bg-purple-700 text-white font-bold rounded-lg">
                        üèÜ Add All Position Night Matches (${numPositionMatches}${hasPositionBye ? ' + bye' : ''})
                    </button>
                    <button onclick="window.state.scheduleMode = null; window.state.autoGenMode = null; window.render();" 
                        class="px-6 py-3 bg-slate-200 text-slate-700 font-bold rounded-lg hover:bg-slate-300">
                        Done
                    </button>
                </div>
                ` : `
                <!-- Regular Match Entry -->
                <div class="grid md:grid-cols-3 gap-4 mb-6">
                    <div>
                        <label class="block text-sm font-semibold text-slate-700 mb-1">Away Team</label>
                        <select id="manual-away" 
                            onchange="window.state.manualMatch.awayTeamId = this.value;"
                            class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg focus:border-emerald-500">
                            <option value="">Select away team...</option>
                            <option value="BYE" ${m.awayTeamId === 'BYE' ? 'selected' : ''}>üèñÔ∏è BYE WEEK</option>
                            ${sortedTeams.filter(t => t.id !== m.homeTeamId).map(t => `<option value="${t.id}" ${m.awayTeamId === t.id ? 'selected' : ''}>${t.name}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-semibold text-slate-700 mb-1">Home Team *</label>
                        <select id="manual-home" 
                            onchange="window.state.manualMatch.homeTeamId = this.value; updateManualVenue();"
                            class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg focus:border-emerald-500">
                            <option value="">Select home team...</option>
                            ${sortedTeams.map(t => `<option value="${t.id}" ${m.homeTeamId === t.id ? 'selected' : ''}>${t.name}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-semibold text-slate-700 mb-1">Venue</label>
                        <select id="manual-venue" 
                            onchange="window.state.manualMatch.venue = this.value;"
                            class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg focus:border-emerald-500">
                            <option value="">Select venue...</option>
                            ${allVenues.map(v => `<option value="${v}" ${m.venue === v ? 'selected' : ''}>${v}</option>`).join('')}
                            <option value="TBD" ${m.venue === 'TBD' ? 'selected' : ''}>TBD</option>
                        </select>
                        <p class="text-xs text-slate-500 mt-1">Auto-fills from home team</p>
                    </div>
                </div>
                
                <div class="flex gap-4">
                    <button onclick="addManualMatch()" 
                        class="flex-1 py-3 bg-emerald-600 hover:bg-emerald-700 text-white font-bold rounded-lg">
                        ‚ûï Add Match
                    </button>
                    <button onclick="window.state.scheduleMode = null; window.state.autoGenMode = null; window.render();" 
                        class="px-6 py-3 bg-slate-200 text-slate-700 font-bold rounded-lg hover:bg-slate-300">
                        Done
                    </button>
                </div>
                `}
            `;
        }
        
        // Week entry form
        function renderWeekEntry(allVenues) {
            const numTeams = (state.teams || []).length;
            
            if (numTeams < 2) {
                return `
                    <div class="text-center py-8 text-slate-500">
                        <p>You need at least 2 teams to create a week schedule.</p>
                    </div>
                `;
            }
            
            // Initialize weekMatches if empty
            if (state.weekMatches.length === 0) {
                initWeekMatches();
            }
            
            const usedTeams = getUsedTeamsInWeek();
            
            return `
                <div class="space-y-4 mb-6">
                    <div class="flex items-center justify-between">
                        <h4 class="font-bold text-slate-700">Week ${state.manualMatch.week || '?'} Matches (${(state.teams || []).length} teams)</h4>
                        <button onclick="window.initWeekMatches(); window.render();" 
                            class="text-sm text-blue-600 hover:text-blue-800">üîÑ Reset All</button>
                    </div>
                    
                    ${state.weekMatches.map((match, idx) => {
                        const availableHome = getAvailableTeamsForSlot(match, 'homeTeamId');
                        const availableAway = getAvailableTeamsForSlot(match, 'awayTeamId');
                        const homeTeam = (state.teams || []).find(t => t.id === match.homeTeamId);
                        
                        if (match.isBye) {
                            // BYE slot
                            return `
                                <div class="p-4 bg-blue-50 border-2 border-blue-200 rounded-lg">
                                    <div class="flex items-center gap-4">
                                        <span class="text-lg font-bold text-blue-600">üèñÔ∏è</span>
                                        <div class="flex-1">
                                            <label class="block text-xs font-bold uppercase text-blue-600 mb-1">BYE Week</label>
                                            <select onchange="window.updateWeekMatch(${idx}, 'homeTeamId', this.value)"
                                                class="w-full px-3 py-2 border-2 border-blue-300 rounded-lg bg-white">
                                                <option value="">Select team for bye...</option>
                                                ${availableHome.map(t => `<option value="${t.id}" ${match.homeTeamId === t.id ? 'selected' : ''}>${t.name}</option>`).join('')}
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                        
                        // Regular match slot
                        return `
                            <div class="p-4 bg-slate-50 border-2 border-slate-200 rounded-lg">
                                <div class="grid md:grid-cols-7 gap-3 items-end">
                                    <div class="md:col-span-2">
                                        <label class="block text-xs font-bold uppercase text-slate-500 mb-1">Away Team</label>
                                        <select onchange="window.updateWeekMatch(${idx}, 'awayTeamId', this.value)"
                                            class="w-full px-3 py-2 border-2 border-slate-300 rounded-lg">
                                            <option value="">Select...</option>
                                            ${availableAway.map(t => `<option value="${t.id}" ${match.awayTeamId === t.id ? 'selected' : ''}>${t.name}</option>`).join('')}
                                        </select>
                                    </div>
                                    
                                    <div class="text-center font-bold text-slate-400 py-2">@</div>
                                    
                                    <div class="md:col-span-2">
                                        <label class="block text-xs font-bold uppercase text-slate-500 mb-1">Home Team</label>
                                        <select onchange="window.updateWeekMatch(${idx}, 'homeTeamId', this.value)"
                                            class="w-full px-3 py-2 border-2 border-slate-300 rounded-lg">
                                            <option value="">Select...</option>
                                            ${availableHome.map(t => `<option value="${t.id}" ${match.homeTeamId === t.id ? 'selected' : ''}>${t.name}</option>`).join('')}
                                        </select>
                                    </div>
                                    
                                    <div class="md:col-span-2">
                                        <label class="block text-xs font-bold uppercase text-slate-500 mb-1">Venue</label>
                                        <select onchange="window.updateWeekMatch(${idx}, 'venue', this.value)"
                                            class="w-full px-3 py-2 border-2 border-slate-300 rounded-lg">
                                            <option value="">Select...</option>
                                            ${allVenues.map(v => `<option value="${v}" ${match.venue === v ? 'selected' : ''}>${v}</option>`).join('')}
                                            <option value="TBD" ${match.venue === 'TBD' ? 'selected' : ''}>TBD</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                    
                    <!-- Summary -->
                    <div class="p-3 bg-slate-100 rounded-lg text-sm text-slate-600">
                        <strong>Teams assigned:</strong> ${usedTeams.size} / ${numTeams}
                        ${usedTeams.size < numTeams ? `<span class="text-amber-600 ml-2">‚ö†Ô∏è ${numTeams - usedTeams.size} team(s) not assigned</span>` : '<span class="text-emerald-600 ml-2">‚úì All teams assigned</span>'}
                    </div>
                </div>
                
                <div class="flex gap-4">
                    <button onclick="window.addWeekMatches()" 
                        class="flex-1 py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">
                        üìÖ Add Week ${state.manualMatch.week || ''} (${state.weekMatches.length} matches)
                    </button>
                    <button onclick="window.state.scheduleMode = null; window.state.autoGenMode = null; window.render();" 
                        class="px-6 py-3 bg-slate-200 text-slate-700 font-bold rounded-lg hover:bg-slate-300">
                        Done
                    </button>
                </div>
            `;
        }
        
        // Auto-generate options page
        function renderAutoGenerateOptions() {
            const autoMode = state.autoGenMode;
            
            return `
                <div class="bg-white rounded-xl shadow-lg p-6">
                    <div class="flex items-center justify-between mb-6">
                        <h3 class="text-xl font-bold">üîÑ Auto Generate Schedule</h3>
                        <button onclick="window.state.scheduleMode = 'choose'; window.state.autoGenMode = null; window.render();" 
                            class="text-sm text-slate-600 hover:text-slate-800">‚Üê Back to options</button>
                    </div>
                    
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                        <p class="text-blue-800 text-sm">
                            <strong>Adding to:</strong> ${state.currentSeason?.name || 'No season selected'}
                        </p>
                    </div>
                    
                    <!-- Auto-generate options grid -->
                    <div class="grid md:grid-cols-2 gap-4 mb-6">
                        <!-- Round Robin (Standard) -->
                        <button onclick="window.state.autoGenMode = 'roundrobin'; window.render();" 
                            class="p-6 border-2 ${autoMode === 'roundrobin' ? 'border-blue-500 bg-blue-50' : 'border-slate-200'} rounded-xl hover:border-blue-400 text-left transition-all">
                            <div class="text-3xl mb-2">üîÅ</div>
                            <h4 class="font-bold text-slate-800">Round Robin (Standard)</h4>
                            <p class="text-sm text-slate-600 mt-1">Default settings: 5 matches/night, best of 3, weekly on the start date's day.</p>
                        </button>
                        
                        <!-- Custom Round Robin -->
                        <button onclick="window.state.autoGenMode = 'customrr'; window.render();" 
                            class="p-6 border-2 ${autoMode === 'customrr' ? 'border-emerald-500 bg-emerald-50' : 'border-slate-200'} rounded-xl hover:border-emerald-400 text-left transition-all">
                            <div class="text-3xl mb-2">‚öôÔ∏è</div>
                            <h4 class="font-bold text-slate-800">Round Robin (Custom)</h4>
                            <p class="text-sm text-slate-600 mt-1">Customize matches per night, games to win, play days, and frequency.</p>
                        </button>
                        
                        <!-- CSV Import -->
                        <button onclick="window.state.autoGenMode = 'csv'; window.render();" 
                            class="p-6 border-2 ${autoMode === 'csv' ? 'border-blue-500 bg-blue-50' : 'border-slate-200'} rounded-xl hover:border-blue-400 text-left transition-all">
                            <div class="text-3xl mb-2">üìÑ</div>
                            <h4 class="font-bold text-slate-800">Import from CSV</h4>
                            <p class="text-sm text-slate-600 mt-1">Upload a CSV file with your schedule data.</p>
                        </button>
                        
                        <!-- Coming Soon placeholders -->
                        <div class="p-6 border-2 border-dashed border-slate-200 rounded-xl opacity-50">
                            <div class="text-3xl mb-2">üèÜ</div>
                            <h4 class="font-bold text-slate-400">Single Elimination</h4>
                            <p class="text-sm text-slate-400 mt-1">Coming soon...</p>
                        </div>
                    </div>
                    
                    <!-- Selected option content -->
                    ${autoMode === 'roundrobin' ? renderRoundRobinForm() : ''}
                    ${autoMode === 'customrr' ? renderCustomRoundRobinForm() : ''}
                    ${autoMode === 'csv' ? renderCSVImportForm() : ''}
                </div>
            `;
        }
        
        // Round Robin generation form
        function renderRoundRobinForm() {
            return `
                <div class="border-t pt-6 mt-6">
                    <h4 class="font-bold mb-4">üîÅ Round Robin Settings</h4>
                    
                    <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-4">
                        <p class="text-yellow-800 text-sm font-semibold">‚ö†Ô∏è This will replace the current schedule</p>
                        <p class="text-yellow-700 text-xs mt-1">All existing matches in "${state.currentSeason?.name}" will be deleted.</p>
                    </div>
                    
                    <div class="grid md:grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-1">Start Date</label>
                            <input type="date" id="rr-start-date" class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-1">Teams</label>
                            <div class="px-4 py-2 bg-slate-100 rounded-lg text-slate-700">
                                ${state.teams.length} teams registered
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-slate-50 p-4 rounded-lg mb-4">
                        <h5 class="font-semibold text-sm mb-2">Schedule Preview:</h5>
                        <ul class="text-xs text-slate-600 space-y-1">
                            <li>‚úì ${state.teams.length} teams √ó 2 halves = ${state.teams.length * 2} regular weeks</li>
                            <li>‚úì + 2 Position Nights = ${state.teams.length * 2 + 2} total weeks</li>
                            <li>‚úì Each team gets 1 bye per half</li>
                            <li>‚úì Home/away reversed between halves</li>
                        </ul>
                    </div>
                    
                    <button onclick="generateRoundRobinScheduleFromUI()" 
                        class="w-full py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">
                        üöÄ Generate Round Robin Schedule
                    </button>
                </div>
            `;
        }
        
        // Custom Round Robin form with all options
        function renderCustomRoundRobinForm() {
            const cfg = state.customRR;
            const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            
            return `
                <div class="border-t pt-6 mt-6">
                    <h4 class="font-bold mb-4">‚öôÔ∏è Custom Round Robin Settings</h4>
                    
                    <div class="bg-yellow-50 border border-yellow-300 rounded-lg p-3 mb-4">
                        <p class="text-yellow-800 text-sm font-semibold">‚ö†Ô∏è This will replace the current schedule</p>
                        <p class="text-yellow-700 text-xs mt-1">All existing matches in "${state.currentSeason?.name}" will be deleted.</p>
                    </div>
                    
                    <!-- Start Date -->
                    <div class="mb-6">
                        <label class="block text-sm font-semibold text-slate-700 mb-1">Start Date</label>
                        <input type="date" id="custom-rr-start-date" class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg">
                        <p class="text-xs text-slate-500 mt-1">First match night of the season</p>
                    </div>
                    
                    <!-- Match Settings -->
                    <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mb-6">
                        <h5 class="font-semibold text-emerald-800 mb-3">üé± Match Settings</h5>
                        
                        <div class="grid md:grid-cols-2 gap-4">
                            <!-- Matches Per Night -->
                            <div>
                                <label class="block text-sm font-semibold text-slate-700 mb-1">Matches Per Night</label>
                                <select id="custom-rr-matches" onchange="window.state.customRR.matchesPerNight = parseInt(this.value); window.render();"
                                    class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg">
                                    ${[1,2,3,4,5,6,7,8,9,10].map(n => `
                                        <option value="${n}" ${cfg.matchesPerNight === n ? 'selected' : ''}>${n} match${n > 1 ? 'es' : ''}</option>
                                    `).join('')}
                                </select>
                                <p class="text-xs text-slate-500 mt-1">How many individual player matches per team match</p>
                            </div>
                            
                            <!-- Best Of -->
                            <div>
                                <label class="block text-sm font-semibold text-slate-700 mb-1">Games to Win (Best of)</label>
                                <select id="custom-rr-bestof" onchange="window.state.customRR.bestOf = parseInt(this.value); window.render();"
                                    class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg">
                                    ${[1,2,3,4,5].map(n => {
                                        const bestOf = n * 2 - 1;
                                        return `<option value="${n}" ${cfg.bestOf === n ? 'selected' : ''}>Best of ${bestOf} (first to ${n})</option>`;
                                    }).join('')}
                                </select>
                                <p class="text-xs text-slate-500 mt-1">Games needed to win each individual match</p>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Schedule Settings -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                        <h5 class="font-semibold text-blue-800 mb-3">üìÖ Schedule Settings</h5>
                        
                        <!-- Play Days -->
                        <div class="mb-4">
                            <label class="block text-sm font-semibold text-slate-700 mb-2">Play Days</label>
                            <p class="text-xs text-slate-500 mb-2">Select which days of the week matches can be played</p>
                            <div class="flex flex-wrap gap-2">
                                ${days.map(day => `
                                    <label class="flex items-center gap-2 px-3 py-2 rounded-lg border-2 cursor-pointer transition-all
                                        ${cfg.playDays.includes(day) ? 'bg-blue-100 border-blue-400 text-blue-800' : 'bg-white border-slate-200 text-slate-600 hover:border-slate-300'}">
                                        <input type="checkbox" 
                                            ${cfg.playDays.includes(day) ? 'checked' : ''} 
                                            onchange="togglePlayDay('${day}')"
                                            class="sr-only">
                                        <span class="font-medium text-sm capitalize">${day.slice(0,3)}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                        
                        <!-- Frequency -->
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-2">Frequency</label>
                            <div class="flex gap-3">
                                <label class="flex items-center gap-2 px-4 py-3 rounded-lg border-2 cursor-pointer transition-all flex-1
                                    ${cfg.frequency === 'weekly' ? 'bg-blue-100 border-blue-400 text-blue-800' : 'bg-white border-slate-200 text-slate-600 hover:border-slate-300'}">
                                    <input type="radio" name="frequency" value="weekly" 
                                        ${cfg.frequency === 'weekly' ? 'checked' : ''}
                                        onchange="window.state.customRR.frequency = 'weekly'; window.render();"
                                        class="sr-only">
                                    <div>
                                        <div class="font-semibold">Weekly</div>
                                        <div class="text-xs opacity-75">Every week</div>
                                    </div>
                                </label>
                                <label class="flex items-center gap-2 px-4 py-3 rounded-lg border-2 cursor-pointer transition-all flex-1
                                    ${cfg.frequency === 'biweekly' ? 'bg-blue-100 border-blue-400 text-blue-800' : 'bg-white border-slate-200 text-slate-600 hover:border-slate-300'}">
                                    <input type="radio" name="frequency" value="biweekly" 
                                        ${cfg.frequency === 'biweekly' ? 'checked' : ''}
                                        onchange="window.state.customRR.frequency = 'biweekly'; window.render();"
                                        class="sr-only">
                                    <div>
                                        <div class="font-semibold">Bi-Weekly</div>
                                        <div class="text-xs opacity-75">Every other week</div>
                                    </div>
                                </label>
                            </div>
                        </div>
                        
                        <!-- Times to Play Each Team -->
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-2">Times to Play Each Team</label>
                            <p class="text-xs text-slate-500 mb-2">How many times should each team face every other team?</p>
                            <div class="flex flex-wrap gap-2">
                                ${[1, 2, 3, 4].map(n => `
                                    <label class="flex items-center gap-2 px-4 py-3 rounded-lg border-2 cursor-pointer transition-all
                                        ${cfg.timesToPlay === n ? 'bg-blue-100 border-blue-400 text-blue-800' : 'bg-white border-slate-200 text-slate-600 hover:border-slate-300'}">
                                        <input type="radio" name="timesToPlay" value="${n}" 
                                            ${cfg.timesToPlay === n ? 'checked' : ''}
                                            onchange="window.state.customRR.timesToPlay = ${n}; window.render();"
                                            class="sr-only">
                                        <div class="text-center">
                                            <div class="font-bold text-lg">${n}x</div>
                                            <div class="text-xs opacity-75">${n === 1 ? 'Single' : n === 2 ? 'Home & Away' : n + ' rounds'}</div>
                                        </div>
                                    </label>
                                `).join('')}
                            </div>
                            <p class="text-xs text-slate-500 mt-2">
                                ${cfg.timesToPlay === 1 ? '‚Ä¢ Each team plays every other team once' : 
                                  cfg.timesToPlay === 2 ? '‚Ä¢ Each team plays every other team twice (once home, once away)' :
                                  '‚Ä¢ Each team plays every other team ' + cfg.timesToPlay + ' times'}
                            </p>
                        </div>
                    </div>
                    
                    <!-- Position Night Settings -->
                    <div class="bg-purple-50 border border-purple-200 rounded-lg p-4 mb-6">
                        <h5 class="font-semibold text-purple-800 mb-3">üèÜ Position Night Settings</h5>
                        
                        <!-- Number of Position Nights -->
                        <div class="mb-4">
                            <label class="block text-sm font-semibold text-slate-700 mb-2">Number of Position Nights</label>
                            <div class="flex flex-wrap gap-2">
                                ${[0, 1, 2, 3, 4].map(n => `
                                    <label class="flex items-center justify-center w-12 h-12 rounded-lg border-2 cursor-pointer transition-all
                                        ${cfg.positionNights === n ? 'bg-purple-100 border-purple-400 text-purple-800' : 'bg-white border-slate-200 text-slate-600 hover:border-slate-300'}">
                                        <input type="radio" name="positionNights" value="${n}" 
                                            ${cfg.positionNights === n ? 'checked' : ''}
                                            onchange="window.state.customRR.positionNights = ${n}; window.render();"
                                            class="sr-only">
                                        <span class="font-bold text-lg">${n}</span>
                                    </label>
                                `).join('')}
                            </div>
                            <p class="text-xs text-slate-500 mt-1">Position nights match teams by standings (1st vs 2nd, 3rd vs 4th, etc.)</p>
                        </div>
                        
                        <!-- Position Night Placement (only show if > 0 position nights) -->
                        ${cfg.positionNights > 0 ? `
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-2">When to Schedule Position Nights</label>
                            <div class="space-y-2">
                                <label class="flex items-start gap-3 p-3 rounded-lg border-2 cursor-pointer transition-all
                                    ${cfg.positionNightPlacement === 'half' ? 'bg-purple-100 border-purple-400' : 'bg-white border-slate-200 hover:border-slate-300'}">
                                    <input type="radio" name="positionPlacement" value="half" 
                                        ${cfg.positionNightPlacement === 'half' ? 'checked' : ''}
                                        onchange="window.state.customRR.positionNightPlacement = 'half'; window.render();"
                                        class="mt-1">
                                    <div>
                                        <div class="font-semibold text-slate-800">Split Evenly</div>
                                        <div class="text-xs text-slate-600">Distribute position nights evenly throughout the season (e.g., after each half)</div>
                                    </div>
                                </label>
                                <label class="flex items-start gap-3 p-3 rounded-lg border-2 cursor-pointer transition-all
                                    ${cfg.positionNightPlacement === 'end' ? 'bg-purple-100 border-purple-400' : 'bg-white border-slate-200 hover:border-slate-300'}">
                                    <input type="radio" name="positionPlacement" value="end" 
                                        ${cfg.positionNightPlacement === 'end' ? 'checked' : ''}
                                        onchange="window.state.customRR.positionNightPlacement = 'end'; window.render();"
                                        class="mt-1">
                                    <div>
                                        <div class="font-semibold text-slate-800">All at End</div>
                                        <div class="text-xs text-slate-600">Schedule all position nights at the end of the season (playoffs style)</div>
                                    </div>
                                </label>
                                <label class="flex items-start gap-3 p-3 rounded-lg border-2 cursor-pointer transition-all
                                    ${cfg.positionNightPlacement === 'start' ? 'bg-purple-100 border-purple-400' : 'bg-white border-slate-200 hover:border-slate-300'}">
                                    <input type="radio" name="positionPlacement" value="start" 
                                        ${cfg.positionNightPlacement === 'start' ? 'checked' : ''}
                                        onchange="window.state.customRR.positionNightPlacement = 'start'; window.render();"
                                        class="mt-1">
                                    <div>
                                        <div class="font-semibold text-slate-800">All at Start</div>
                                        <div class="text-xs text-slate-600">Schedule position nights at the beginning (seeding rounds)</div>
                                    </div>
                                </label>
                            </div>
                        </div>
                        ` : `
                        <div class="text-sm text-slate-500 italic">
                            No position nights - season will only have regular round-robin matches.
                        </div>
                        `}
                    </div>
                    
                    <!-- Bye Week Settings -->
                    <div class="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">
                        <h5 class="font-semibold text-amber-800 mb-3">üèñÔ∏è Bye Week Settings</h5>
                        
                        <div>
                            <label class="block text-sm font-semibold text-slate-700 mb-2">How are bye weeks scored?</label>
                            <div class="space-y-2">
                                <label class="flex items-start gap-3 p-3 rounded-lg border-2 cursor-pointer transition-all
                                    ${cfg.byePoints === 'win' ? 'bg-amber-100 border-amber-400' : 'bg-white border-slate-200 hover:border-slate-300'}">
                                    <input type="radio" name="byePoints" value="win" 
                                        ${cfg.byePoints === 'win' ? 'checked' : ''}
                                        onchange="window.state.customRR.byePoints = 'win'; window.render();"
                                        class="mt-1">
                                    <div>
                                        <div class="font-semibold text-slate-800">Counts as a Win</div>
                                        <div class="text-xs text-slate-600">Team receives credit for a match win and ${cfg.matchesPerNight} game wins during bye week</div>
                                    </div>
                                </label>
                                <label class="flex items-start gap-3 p-3 rounded-lg border-2 cursor-pointer transition-all
                                    ${cfg.byePoints === 'none' ? 'bg-amber-100 border-amber-400' : 'bg-white border-slate-200 hover:border-slate-300'}">
                                    <input type="radio" name="byePoints" value="none" 
                                        ${cfg.byePoints === 'none' ? 'checked' : ''}
                                        onchange="window.state.customRR.byePoints = 'none'; window.render();"
                                        class="mt-1">
                                    <div>
                                        <div class="font-semibold text-slate-800">Worth Nothing</div>
                                        <div class="text-xs text-slate-600">Bye weeks don't count toward standings - no wins or games credited</div>
                                    </div>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Preview -->
                    <div class="bg-slate-50 p-4 rounded-lg mb-4">
                        <h5 class="font-semibold text-sm mb-2">üìä Schedule Preview:</h5>
                        <ul class="text-xs text-slate-600 space-y-1">
                            <li>‚úì <strong>${state.teams.length}</strong> teams registered</li>
                            <li>‚úì <strong>${cfg.matchesPerNight}</strong> individual matches per team match</li>
                            <li>‚úì <strong>Best of ${cfg.bestOf * 2 - 1}</strong> (first to ${cfg.bestOf} wins)</li>
                            <li>‚úì Play on: <strong>${cfg.playDays.length > 0 ? cfg.playDays.map(d => d.charAt(0).toUpperCase() + d.slice(1,3)).join(', ') : 'No days selected!'}</strong></li>
                            <li>‚úì Frequency: <strong>${cfg.frequency === 'weekly' ? 'Every week' : 'Every 2 weeks'}</strong></li>
                            <li>‚úì Play each team: <strong>${cfg.timesToPlay}x</strong> ${cfg.timesToPlay === 2 ? '(home & away)' : ''}</li>
                            <li>‚úì <strong>${cfg.positionNights}</strong> position night${cfg.positionNights !== 1 ? 's' : ''} ${cfg.positionNights > 0 ? `(${cfg.positionNightPlacement === 'half' ? 'split evenly' : cfg.positionNightPlacement === 'end' ? 'at end' : 'at start'})` : ''}</li>
                            <li>‚úì Bye weeks: <strong>${cfg.byePoints === 'win' ? 'Count as wins' : 'Worth nothing'}</strong></li>
                            <li>‚úì ${state.teams.length * cfg.timesToPlay} regular weeks + ${cfg.positionNights} position nights = <strong>${state.teams.length * cfg.timesToPlay + cfg.positionNights} total weeks</strong></li>
                            <li>‚úì Estimated duration: <strong>~${Math.ceil((state.teams.length * cfg.timesToPlay + cfg.positionNights) * (cfg.frequency === 'biweekly' ? 2 : 1))} weeks</strong></li>
                        </ul>
                    </div>
                    
                    <button onclick="generateCustomRoundRobinSchedule()" 
                        ${cfg.playDays.length === 0 ? 'disabled' : ''}
                        class="w-full py-3 bg-emerald-600 text-white font-bold rounded-lg hover:bg-emerald-700 disabled:opacity-50 disabled:cursor-not-allowed">
                        üöÄ Generate Custom Schedule
                    </button>
                </div>
            `;
        }
        
        // Toggle play day selection
        function togglePlayDay(day) {
            const days = state.customRR.playDays;
            const idx = days.indexOf(day);
            if (idx > -1) {
                days.splice(idx, 1);
            } else {
                days.push(day);
            }
            render();
        }
        window.togglePlayDay = togglePlayDay;
        
        // Generate custom round robin schedule
        async function generateCustomRoundRobinSchedule() {
            const startDateVal = document.getElementById('custom-rr-start-date')?.value;
            if (!startDateVal) {
                alert('Please select a start date');
                return;
            }
            
            const cfg = state.customRR;
            if (cfg.playDays.length === 0) {
                alert('Please select at least one play day');
                return;
            }
            
            if (state.teams.length < 2) {
                alert('Need at least 2 teams to generate a schedule');
                return;
            }
            
            const confirmMsg = `Generate custom round-robin schedule for "${state.currentSeason?.name}"?\n\nThis will DELETE all existing matches in this season and create a new schedule.`;
            if (!confirm(confirmMsg)) return;
            
            showLoading();
            try {
                const seasonId = state.currentSeason.id;
                const orgId = state.organization.id;
                
                // Clear existing schedule for this season
                await db.from('matches').delete().eq('season_id', seasonId);
                await db.from('submissions').delete().eq('season_id', seasonId);
                await db.from('schedule').delete().eq('season_id', seasonId);
                
                // Generate the schedule using the custom settings
                const schedule = generateCustomRRSchedule(startDateVal, cfg);
                
                if (!schedule || schedule.length === 0) {
                    alert('Failed to generate schedule. Please try again.');
                    return;
                }
                
                // Convert to database format
                const dbSchedule = schedule.map(s => ({
                    week: s.week,
                    date: s.date,
                    home_team_id: s.homeTeamId,
                    away_team_id: s.awayTeamId,
                    venue: s.venue,
                    is_bye: s.isBye,
                    half: s.half,
                    is_position_night: s.isPositionNight,
                    position_home: s.positionHome,
                    position_away: s.positionAway,
                    season_id: seasonId,
                    org_id: orgId,
                    match_format: s.matchFormat
                }));
                
                const { data, error } = await db.from('schedule').insert(dbSchedule).select();
                
                if (error) throw error;
                
                // Convert back to app format
                state.schedule = data.map(s => ({
                    id: s.id,
                    week: s.week,
                    date: s.date,
                    homeTeamId: s.home_team_id,
                    awayTeamId: s.away_team_id,
                    venue: s.venue,
                    isBye: s.is_bye,
                    half: s.half,
                    isPositionNight: s.is_position_night,
                    positionHome: s.position_home,
                    positionAway: s.position_away,
                    seasonId: s.season_id,
                    orgId: s.org_id,
                    matchFormat: s.match_format
                }));
                
                state.matches = [];
                state.submissions = [];
                state.scheduleMode = null;
                state.autoGenMode = null;
                
                alert(`Schedule generated successfully!\n\n‚Ä¢ ${schedule.filter(s => !s.isBye && !s.isPositionNight).length} regular matches\n‚Ä¢ ${schedule.filter(s => s.isBye).length} bye weeks\n‚Ä¢ ${schedule.filter(s => s.isPositionNight).length} position night matches\n\nMatch format: Best of ${cfg.bestOf * 2 - 1} (${cfg.matchesPerNight} matches per night)`);
                render();
            } catch (error) {
                console.error('Error generating schedule:', error);
                alert('Error generating schedule: ' + error.message);
            } finally {
                hideLoading();
            }
        }
        window.generateCustomRoundRobinSchedule = generateCustomRoundRobinSchedule;
        
        // Custom RR schedule generator - uses circle method with custom date logic
        function generateCustomRRSchedule(startDate, cfg) {
            const teams = [...state.teams];
            const numTeams = teams.length;
            const newSchedule = [];
            
            // Add BYE placeholder for odd number of teams
            const teamList = [...teams];
            if (numTeams % 2 === 1) {
                teamList.push({ id: 'BYE_PLACEHOLDER', name: 'BYE', venue: 'BYE WEEK' });
            }
            
            const n = teamList.length;
            const rounds = n - 1;
            
            // Calculate dates based on play days and frequency
            const dayMap = { sunday: 0, monday: 1, tuesday: 2, wednesday: 3, thursday: 4, friday: 5, saturday: 6 };
            const playDayNums = cfg.playDays.map(d => dayMap[d]).sort((a, b) => a - b);
            
            let currentDate = new Date(startDate);
            let weekNum = 0;
            
            // Helper to get next valid play date
            function getNextPlayDate(fromDate, skipWeeks = 0) {
                let date = new Date(fromDate);
                if (skipWeeks > 0) {
                    date.setDate(date.getDate() + (skipWeeks * 7));
                }
                
                // Find next valid play day
                for (let i = 0; i < 14; i++) {
                    const dow = date.getDay();
                    if (playDayNums.includes(dow)) {
                        break;
                    }
                    date.setDate(date.getDate() + 1);
                }
                
                return date;
            }
            
            // Helper to add position night(s)
            function addPositionNight(posNightNum) {
                weekNum++;
                const positionDate = currentDate.toISOString().split('T')[0];
                const numPositionMatches = Math.floor(numTeams / 2);
                
                for (let pos = 0; pos < numPositionMatches; pos++) {
                    const position1 = (pos * 2) + 1;
                    const position2 = (pos * 2) + 2;
                    
                    newSchedule.push({
                        id: `${Date.now()}-pos-${posNightNum}-${pos}-${Math.random()}`,
                        week: weekNum.toString(),
                        date: positionDate,
                        homeTeamId: `POSITION_${position1}`,
                        awayTeamId: `POSITION_${position2}`,
                        venue: 'TBD - Based on Standings',
                        isBye: false,
                        half: posNightNum,
                        isPositionNight: true,
                        positionHome: position1,
                        positionAway: position2,
                        positionNightNumber: posNightNum,
                        matchFormat: { matchesPerNight: cfg.matchesPerNight, bestOf: cfg.bestOf, byePoints: cfg.byePoints }
                    });
                }
                
                // Odd team bye on position night
                if (numTeams % 2 === 1) {
                    newSchedule.push({
                        id: `${Date.now()}-pos-${posNightNum}-bye-${Math.random()}`,
                        week: weekNum.toString(),
                        date: positionDate,
                        homeTeamId: `POSITION_${numTeams}`,
                        awayTeamId: 'BYE',
                        venue: 'BYE WEEK',
                        isBye: true,
                        half: posNightNum,
                        isPositionNight: true,
                        positionHome: numTeams,
                        positionNightNumber: posNightNum
                    });
                }
                
                // Move to next date
                const weeksToSkip = cfg.frequency === 'biweekly' ? 2 : 1;
                currentDate = getNextPlayDate(currentDate, weeksToSkip);
            }
            
            // Adjust start date to first valid play day
            currentDate = getNextPlayDate(currentDate);
            
            // Position nights at START
            if (cfg.positionNightPlacement === 'start' && cfg.positionNights > 0) {
                for (let pn = 1; pn <= cfg.positionNights; pn++) {
                    addPositionNight(pn);
                }
            }
            
            // Calculate when to insert position nights for 'half' placement
            const timesToPlay = cfg.timesToPlay || 2;
            const totalRounds = rounds * timesToPlay;
            let positionNightsInserted = 0;
            const positionNightInterval = cfg.positionNights > 0 ? Math.floor(totalRounds / (cfg.positionNights + 1)) : 0;
            let roundsSinceLastPosition = 0;
            
            // Track home/away history for fair distribution
            const homeAwayHistory = {}; // key: matchKey, value: array of home team ids
            
            for (let roundSet = 1; roundSet <= timesToPlay; roundSet++) {
                const rotating = [...teamList];
                
                for (let round = 0; round < rounds; round++) {
                    weekNum++;
                    const matchDate = currentDate.toISOString().split('T')[0];
                    
                    // Generate matches for this round
                    for (let i = 0; i < n / 2; i++) {
                        const team1 = rotating[i];
                        const team2 = rotating[n - 1 - i];
                        
                        if (team1.id === 'BYE_PLACEHOLDER' && team2.id === 'BYE_PLACEHOLDER') continue;
                        
                        // Bye week
                        if (team1.id === 'BYE_PLACEHOLDER') {
                            newSchedule.push({
                                id: `${Date.now()}-${weekNum}-bye-${team2.id}-${Math.random()}`,
                                week: weekNum.toString(),
                                date: matchDate,
                                homeTeamId: team2.id,
                                awayTeamId: 'BYE',
                                venue: 'BYE WEEK',
                                isBye: true,
                                half: roundSet,
                                isPositionNight: false,
                                matchFormat: { matchesPerNight: cfg.matchesPerNight, bestOf: cfg.bestOf, byePoints: cfg.byePoints }
                            });
                            continue;
                        }
                        
                        if (team2.id === 'BYE_PLACEHOLDER') {
                            newSchedule.push({
                                id: `${Date.now()}-${weekNum}-bye-${team1.id}-${Math.random()}`,
                                week: weekNum.toString(),
                                date: matchDate,
                                homeTeamId: team1.id,
                                awayTeamId: 'BYE',
                                venue: 'BYE WEEK',
                                isBye: true,
                                half: roundSet,
                                isPositionNight: false,
                                matchFormat: { matchesPerNight: cfg.matchesPerNight, bestOf: cfg.bestOf, byePoints: cfg.byePoints }
                            });
                            continue;
                        }
                        
                        // Regular match - determine home/away
                        let home, away;
                        const matchKey = [team1.id, team2.id].sort().join('-');
                        
                        // Initialize history if needed
                        if (!homeAwayHistory[matchKey]) {
                            homeAwayHistory[matchKey] = [];
                        }
                        
                        // Count previous home games for each team in this matchup
                        const team1HomeCount = homeAwayHistory[matchKey].filter(id => id === team1.id).length;
                        const team2HomeCount = homeAwayHistory[matchKey].filter(id => id === team2.id).length;
                        
                        // Assign home to team with fewer home games, or alternate based on round
                        if (team1HomeCount < team2HomeCount) {
                            home = team1;
                            away = team2;
                        } else if (team2HomeCount < team1HomeCount) {
                            home = team2;
                            away = team1;
                        } else {
                            // Equal home counts, alternate based on round + position
                            if ((round + i + roundSet) % 2 === 0) {
                                home = team1;
                                away = team2;
                            } else {
                                home = team2;
                                away = team1;
                            }
                        }
                        
                        // Record this assignment
                        homeAwayHistory[matchKey].push(home.id);
                        
                        newSchedule.push({
                            id: `${Date.now()}-${weekNum}-${home.id}-${away.id}-${Math.random()}`,
                            week: weekNum.toString(),
                            date: matchDate,
                            homeTeamId: home.id,
                            awayTeamId: away.id,
                            venue: home.venue || 'TBD',
                            isBye: false,
                            half: roundSet,
                            isPositionNight: false,
                            matchFormat: { matchesPerNight: cfg.matchesPerNight, bestOf: cfg.bestOf, byePoints: cfg.byePoints }
                        });
                    }
                    
                    // Move to next date
                    const weeksToSkip = cfg.frequency === 'biweekly' ? 2 : 1;
                    currentDate = getNextPlayDate(currentDate, weeksToSkip);
                    
                    // Rotate
                    const last = rotating.pop();
                    rotating.splice(1, 0, last);
                    
                    // Check if we should insert a position night (for 'half' placement)
                    if (cfg.positionNightPlacement === 'half' && cfg.positionNights > 0) {
                        roundsSinceLastPosition++;
                        if (roundsSinceLastPosition >= positionNightInterval && positionNightsInserted < cfg.positionNights) {
                            positionNightsInserted++;
                            addPositionNight(positionNightsInserted);
                            roundsSinceLastPosition = 0;
                        }
                    }
                }
            }
            
            // Position nights at END
            if (cfg.positionNightPlacement === 'end' && cfg.positionNights > 0) {
                for (let pn = 1; pn <= cfg.positionNights; pn++) {
                    addPositionNight(pn);
                }
            }
            
            // If 'half' placement and we haven't inserted all position nights yet, add remaining at end
            if (cfg.positionNightPlacement === 'half' && positionNightsInserted < cfg.positionNights) {
                for (let pn = positionNightsInserted + 1; pn <= cfg.positionNights; pn++) {
                    addPositionNight(pn);
                }
            }
            
            return newSchedule.sort((a, b) => parseInt(a.week) - parseInt(b.week));
        }
        
        // CSV Import form
        function renderCSVImportForm() {
            return `
                <div class="border-t pt-6 mt-6">
                    <h4 class="font-bold mb-4">üìÑ Import from CSV</h4>
                    
                    <div class="bg-slate-50 p-4 rounded-lg mb-4">
                        <h5 class="font-semibold text-sm mb-2">CSV Format:</h5>
                        <p class="text-xs text-slate-600 mb-2">Your CSV should have these columns (header row required):</p>
                        <code class="block bg-slate-200 p-2 rounded text-xs">week,date,home,away,venue,half</code>
                        <ul class="text-xs text-slate-500 mt-2 space-y-1">
                            <li>‚Ä¢ <strong>week</strong> - Week number (required)</li>
                            <li>‚Ä¢ <strong>date</strong> - Match date YYYY-MM-DD (required)</li>
                            <li>‚Ä¢ <strong>home</strong> - Home team name (required, must match exactly)</li>
                            <li>‚Ä¢ <strong>away</strong> - Away team name (or "BYE" for bye weeks)</li>
                            <li>‚Ä¢ <strong>venue</strong> - Location (optional)</li>
                            <li>‚Ä¢ <strong>half</strong> - 1 or 2 (optional, defaults to 1)</li>
                        </ul>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-semibold text-slate-700 mb-2">Select CSV File</label>
                        <input type="file" id="csv-file-input" accept=".csv" 
                            class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg">
                    </div>
                    
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-4">
                        <p class="text-blue-800 text-sm">üí° Matches will be <strong>added</strong> to the existing schedule.</p>
                    </div>
                    
                    <button onclick="importScheduleFromCSV(document.getElementById('csv-file-input'))" 
                        class="w-full py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">
                        üì• Import CSV
                    </button>
                    
                    <div class="mt-4 text-center">
                        <button onclick="downloadSampleCSV()" class="text-sm text-blue-600 hover:underline">
                            Download sample CSV template
                        </button>
                    </div>
                </div>
            `;
        }

        function renderSubmitScores() {
            const isAdmin = state.currentUser?.role === 'admin';
            const availMatches = state.schedule.filter(m => {
                if (m.isBye || state.matches.find(x => x.scheduleId === m.id)) return false;
                if (m.isPositionNight) {
                    return getResolvedPositionTeam(m.homeTeamId, m.half) && getResolvedPositionTeam(m.awayTeamId, m.half);
                }
                return true;
            });

            const match = state.schedule.find(m => m.id === state.selectedMatch);
            let home = null, away = null;
            if (match) {
                if (match.isPositionNight) {
                    home = getResolvedPositionTeam(match.homeTeamId, match.half);
                    away = getResolvedPositionTeam(match.awayTeamId, match.half);
                } else {
                    home = state.teams.find(t => t.id === match.homeTeamId);
                    away = state.teams.find(t => t.id === match.awayTeamId);
                }
            }
            
            const canEnterScores = match && home && away && (isAdmin || state.selectedTeam);

            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r ${isAdmin ? 'from-amber-600 to-orange-600' : 'from-emerald-600 to-teal-600'} text-white rounded-xl shadow-lg p-6">
                        <h2 class="text-3xl font-black">${isAdmin ? 'üõ°Ô∏è Post Match Scores' : 'üìù Submit Scores'}</h2>
                        <p class="mt-2 opacity-90">${isAdmin ? 'Admin mode: Scores are posted immediately' : 'Enter the results for each game'}</p>
                    </div>

                    ${isAdmin ? `
                    <div class="bg-amber-50 border-2 border-amber-300 rounded-xl p-4">
                        <div class="flex items-center gap-2">
                            <span class="text-2xl">üõ°Ô∏è</span>
                            <div>
                                <p class="font-bold text-amber-800">Admin Mode Active</p>
                                <p class="text-sm text-amber-700">Scores will be posted immediately without requiring dual-team submission.</p>
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <!-- Scan Scoresheet Section -->
                    <div class="bg-white rounded-xl shadow-lg p-6 border-2 border-blue-200">
                        <h3 class="text-lg font-bold mb-3">üì∑ Scan Scoresheet</h3>
                        <p class="text-sm text-slate-600 mb-4">Take a photo of your completed scoresheet to auto-fill the form.</p>
                        <div class="flex gap-3 flex-wrap">
                            <label class="px-6 py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 cursor-pointer">
                                üì∑ Upload Photo
                                <input type="file" accept="image/*" capture="environment" onchange="handleScoresheetUpload(this)" class="hidden">
                            </label>
                            <label class="px-6 py-3 bg-slate-600 text-white font-bold rounded-lg hover:bg-slate-700 cursor-pointer">
                                üìÅ Choose File
                                <input type="file" accept="image/*" onchange="handleScoresheetUpload(this)" class="hidden">
                            </label>
                        </div>
                        ${ocrStatus ? `<p class="mt-3 text-blue-600 font-semibold">${ocrStatus}</p>` : ''}
                    </div>

                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-lg font-bold mb-4">Or Enter Manually</h3>
                        <div class="grid ${isAdmin ? '' : 'md:grid-cols-2'} gap-4 mb-6">
                            <div>
                                <label class="block text-sm font-bold mb-2">Select Match</label>
                                <select onchange="state.selectedMatch = this.value; window.render();" class="w-full px-4 py-3 border-2 rounded-lg">
                                    <option value="">Choose match...</option>
                                    ${availMatches.map(m => {
                                        let text;
                                        if (m.isPositionNight) {
                                            const h = getResolvedPositionTeam(m.homeTeamId, m.half);
                                            const a = getResolvedPositionTeam(m.awayTeamId, m.half);
                                            text = `Week ${m.week}: ${a?.name} @ ${h?.name}`;
                                        } else {
                                            const h = state.teams.find(t => t.id === m.homeTeamId);
                                            const a = state.teams.find(t => t.id === m.awayTeamId);
                                            text = `Week ${m.week}: ${a?.name} @ ${h?.name}`;
                                        }
                                        return `<option value="${m.id}" ${state.selectedMatch === m.id ? 'selected' : ''}>${text}</option>`;
                                    }).join('')}
                                </select>
                            </div>
                            ${!isAdmin ? `
                            <div>
                                <label class="block text-sm font-bold mb-2">Your Team</label>
                                <select onchange="state.selectedTeam = this.value; window.render();" class="w-full px-4 py-3 border-2 rounded-lg">
                                    <option value="">Select team...</option>
                                    ${[...state.teams].sort((a, b) => a.name.localeCompare(b.name)).map(t => `<option value="${t.id}" ${state.selectedTeam === t.id ? 'selected' : ''}>${t.name}</option>`).join('')}
                                </select>
                            </div>
                            ` : ''}
                        </div>

                        ${canEnterScores ? `
                            <div class="${isAdmin ? 'bg-amber-50 border-amber-200' : 'bg-emerald-50 border-emerald-200'} p-4 rounded-lg border mb-6">
                                <h3 class="font-bold ${isAdmin ? 'text-amber-800' : 'text-emerald-800'}">${away.name} @ ${home.name}</h3>
                            </div>

                            ${(() => {
                                return state.matchups.map((m, i) => {
                                    // For this game, get players selected in OTHER games (exclude current game's selection)
                                    const otherHomeSelections = state.matchups
                                        .filter((_, idx) => idx !== i)
                                        .map(mu => mu.homePlayer)
                                        .filter(p => p);
                                    const otherAwaySelections = state.matchups
                                        .filter((_, idx) => idx !== i)
                                        .map(mu => mu.awayPlayer)
                                        .filter(p => p);
                                    
                                    // Available home players: not selected in other games
                                    const availableHomePlayers = [...(home.players || [])]
                                        .sort((a, b) => a.name.localeCompare(b.name))
                                        .filter(p => !otherHomeSelections.includes(p.id));
                                    
                                    // Available away players: not selected in other games
                                    const availableAwayPlayers = [...(away.players || [])]
                                        .sort((a, b) => a.name.localeCompare(b.name))
                                        .filter(p => !otherAwaySelections.includes(p.id));
                                    
                                    return `
                                        <div class="border rounded-lg p-4 mb-4 bg-slate-50">
                                            <h4 class="font-bold mb-3">Game ${i + 1}</h4>
                                            <div class="grid grid-cols-2 gap-4">
                                                <div>
                                                    <label class="block text-xs font-bold uppercase text-slate-500 mb-1">${home.name}</label>
                                                    <select onchange="state.matchups[${i}].homePlayer = this.value; window.render();" class="w-full px-3 py-2 border rounded">
                                                        <option value="">Select...</option>
                                                        ${availableHomePlayers.map(p => `<option value="${p.id}" ${m.homePlayer === p.id ? 'selected' : ''}>${p.name}</option>`).join('')}
                                                    </select>
                                                    <input type="number" min="0" max="2" placeholder="Games" value="${m.homeGames}" onchange="state.matchups[${i}].homeGames = this.value;" class="w-full px-3 py-2 border rounded mt-2">
                                                </div>
                                                <div>
                                                    <label class="block text-xs font-bold uppercase text-slate-500 mb-1">${away.name}</label>
                                                    <select onchange="state.matchups[${i}].awayPlayer = this.value; window.render();" class="w-full px-3 py-2 border rounded">
                                                        <option value="">Select...</option>
                                                        ${availableAwayPlayers.map(p => `<option value="${p.id}" ${m.awayPlayer === p.id ? 'selected' : ''}>${p.name}</option>`).join('')}
                                                    </select>
                                                    <input type="number" min="0" max="2" placeholder="Games" value="${m.awayGames}" onchange="state.matchups[${i}].awayGames = this.value;" class="w-full px-3 py-2 border rounded mt-2">
                                                </div>
                                            </div>
                                        </div>
                                    `;
                                }).join('');
                            })()}

                            <button onclick="submitScores()" class="w-full ${isAdmin ? 'bg-amber-600 hover:bg-amber-700' : 'bg-emerald-600 hover:bg-emerald-700'} text-white font-bold py-4 rounded-lg">
                                ${isAdmin ? 'üõ°Ô∏è Post Scores (Final)' : 'Submit Scores'}
                            </button>
                        ` : `<div class="text-center py-12 text-slate-500 border-2 border-dashed rounded-lg">${isAdmin ? 'Select a match to enter scores' : 'Select a match and your team'}</div>`}
                    </div>
                </div>
            `;
        }

        function renderStandings() {
            const standings = calcStandings();
            const isAdmin = state.currentUser?.role === 'admin';
            const editing = state.editingStandings;
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6 flex justify-between items-center">
                        <h2 class="text-3xl font-black">üèÜ Standings</h2>
                        ${isAdmin ? `
                            ${editing ? `
                                <div class="flex gap-2">
                                    <button onclick="saveStandingsAdjustments()" class="px-4 py-2 bg-white text-emerald-700 font-bold rounded-lg hover:bg-emerald-50">
                                        üíæ Save Changes
                                    </button>
                                    <button onclick="state.editingStandings = false; render();" class="px-4 py-2 bg-emerald-800 text-white font-bold rounded-lg hover:bg-emerald-900">
                                        ‚úï Cancel
                                    </button>
                                </div>
                            ` : `
                                <button onclick="state.editingStandings = true; render();" class="px-4 py-2 bg-white/20 text-white font-bold rounded-lg hover:bg-white/30">
                                    ‚úèÔ∏è Edit Standings
                                </button>
                            `}
                        ` : ''}
                    </div>
                    
                    ${editing ? `
                        <div class="bg-amber-50 border-2 border-amber-200 rounded-xl p-4">
                            <h3 class="font-bold text-amber-800 mb-2">üìù Editing Mode</h3>
                            <p class="text-sm text-amber-700">Enter adjustments to add/subtract from calculated standings. Use negative numbers to subtract.</p>
                        </div>
                    ` : ''}
                    
                    <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                        <table class="w-full">
                            <thead class="bg-emerald-600 text-white">
                                <tr>
                                    <th class="px-4 py-3 text-left">#</th>
                                    <th class="px-4 py-3 text-left">Team</th>
                                    <th class="px-4 py-3 text-center">W</th>
                                    <th class="px-4 py-3 text-center">L</th>
                                    <th class="px-4 py-3 text-center">GW</th>
                                    <th class="px-4 py-3 text-center">GL</th>
                                    <th class="px-4 py-3 text-center">%</th>
                                    ${editing ? '<th class="px-4 py-3 text-center">Adjustments</th>' : ''}
                                </tr>
                            </thead>
                            <tbody class="divide-y">
                                ${standings.map((t, i) => {
                                    const total = t.wins + t.losses;
                                    const pct = total > 0 ? ((t.wins / total) * 100).toFixed(1) : '0.0';
                                    const adj = state.standingsAdjustments[t.id] || { wins: 0, losses: 0, gamesWon: 0, gamesLost: 0 };
                                    const hasAdj = adj.wins || adj.losses || adj.gamesWon || adj.gamesLost;
                                    
                                    return `
                                        <tr class="hover:bg-emerald-50 ${isAdmin && hasAdj && !editing ? 'bg-amber-50' : ''}">
                                            <td class="px-4 py-3 font-black text-emerald-600">${i + 1}</td>
                                            <td class="px-4 py-3 font-bold">
                                                ${t.name}
                                                ${isAdmin && hasAdj && !editing ? '<span class="ml-2 text-xs bg-amber-200 text-amber-800 px-1 rounded">adjusted</span>' : ''}
                                            </td>
                                            <td class="px-4 py-3 text-center">${t.wins}</td>
                                            <td class="px-4 py-3 text-center">${t.losses}</td>
                                            <td class="px-4 py-3 text-center">${t.gamesWon}</td>
                                            <td class="px-4 py-3 text-center">${t.gamesLost}</td>
                                            <td class="px-4 py-3 text-center font-bold text-emerald-700">${pct}%</td>
                                            ${editing ? `
                                                <td class="px-2 py-2">
                                                    <div class="flex gap-1 items-center text-xs">
                                                        <label class="text-gray-500">W:</label>
                                                        <input type="number" 
                                                            value="${adj.wins || 0}" 
                                                            onchange="updateStandingsAdjustment('${t.id}', 'wins', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                        <label class="text-gray-500 ml-1">L:</label>
                                                        <input type="number" 
                                                            value="${adj.losses || 0}" 
                                                            onchange="updateStandingsAdjustment('${t.id}', 'losses', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                        <label class="text-gray-500 ml-1">GW:</label>
                                                        <input type="number" 
                                                            value="${adj.gamesWon || 0}" 
                                                            onchange="updateStandingsAdjustment('${t.id}', 'gamesWon', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                        <label class="text-gray-500 ml-1">GL:</label>
                                                        <input type="number" 
                                                            value="${adj.gamesLost || 0}" 
                                                            onchange="updateStandingsAdjustment('${t.id}', 'gamesLost', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                    </div>
                                                </td>
                                            ` : ''}
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    ${editing ? `
                        <div class="bg-white rounded-xl shadow-lg p-4">
                            <h3 class="font-bold mb-3">Quick Adjustment Presets</h3>
                            <p class="text-sm text-gray-600 mb-3">Click a team to apply a quick adjustment:</p>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-2">
                                ${state.teams.map(team => `
                                    <div class="border rounded-lg p-2">
                                        <div class="font-semibold text-sm mb-2">${team.name}</div>
                                        <div class="flex gap-1 flex-wrap">
                                            <button onclick="quickAdjust('${team.id}', 1, 0)" class="px-2 py-1 bg-green-100 text-green-800 rounded text-xs hover:bg-green-200">+1 Win</button>
                                            <button onclick="quickAdjust('${team.id}', -1, 0)" class="px-2 py-1 bg-red-100 text-red-800 rounded text-xs hover:bg-red-200">-1 Win</button>
                                            <button onclick="quickAdjust('${team.id}', 0, 1)" class="px-2 py-1 bg-green-100 text-green-800 rounded text-xs hover:bg-green-200">+1 Loss</button>
                                            <button onclick="quickAdjust('${team.id}', 0, -1)" class="px-2 py-1 bg-red-100 text-red-800 rounded text-xs hover:bg-red-200">-1 Loss</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderPlayerStats() {
            const stats = calcPlayerStats();
            const isAdmin = state.currentUser?.role === 'admin';
            const editing = state.editingPlayerStats;
            
            // Group players by team for the quick adjust section
            const teamGroups = {};
            stats.forEach(p => {
                if (!teamGroups[p.team]) teamGroups[p.team] = [];
                teamGroups[p.team].push(p);
            });
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6 flex justify-between items-center">
                        <h2 class="text-3xl font-black">üë§ Player Stats</h2>
                        ${isAdmin ? `
                            ${editing ? `
                                <div class="flex gap-2">
                                    <button onclick="savePlayerStatsAdjustments()" class="px-4 py-2 bg-white text-emerald-700 font-bold rounded-lg hover:bg-emerald-50">
                                        üíæ Save Changes
                                    </button>
                                    <button onclick="state.editingPlayerStats = false; render();" class="px-4 py-2 bg-emerald-800 text-white font-bold rounded-lg hover:bg-emerald-900">
                                        ‚úï Cancel
                                    </button>
                                </div>
                            ` : `
                                <button onclick="state.editingPlayerStats = true; render();" class="px-4 py-2 bg-white/20 text-white font-bold rounded-lg hover:bg-white/30">
                                    ‚úèÔ∏è Edit Stats
                                </button>
                            `}
                        ` : ''}
                    </div>
                    
                    ${editing ? `
                        <div class="bg-amber-50 border-2 border-amber-200 rounded-xl p-4">
                            <h3 class="font-bold text-amber-800 mb-2">üìù Editing Mode</h3>
                            <p class="text-sm text-amber-700">Enter adjustments to add/subtract from calculated stats. Use negative numbers to subtract.</p>
                        </div>
                    ` : ''}
                    
                    <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                        <table class="w-full">
                            <thead class="bg-slate-100">
                                <tr>
                                    <th class="px-4 py-3 text-left">Player</th>
                                    <th class="px-4 py-3 text-left">Team</th>
                                    <th class="px-4 py-3 text-center">MW</th>
                                    <th class="px-4 py-3 text-center">ML</th>
                                    <th class="px-4 py-3 text-center">GW</th>
                                    <th class="px-4 py-3 text-center">GL</th>
                                    <th class="px-4 py-3 text-center">%</th>
                                    ${editing ? '<th class="px-4 py-3 text-center">Adjustments</th>' : ''}
                                </tr>
                            </thead>
                            <tbody class="divide-y">
                                ${stats.map(p => {
                                    const total = p.matchWins + p.matchLosses;
                                    const pct = total > 0 ? ((p.matchWins / total) * 100).toFixed(1) : '0.0';
                                    const adj = state.playerStatsAdjustments[p.id] || { matchWins: 0, matchLosses: 0, gamesWon: 0, gamesLost: 0 };
                                    const hasAdj = adj.matchWins || adj.matchLosses || adj.gamesWon || adj.gamesLost;
                                    
                                    return `
                                        <tr class="hover:bg-slate-50 ${isAdmin && hasAdj && !editing ? 'bg-amber-50' : ''}">
                                            <td class="px-4 py-3 font-semibold">
                                                ${p.name}
                                                ${isAdmin && hasAdj && !editing ? '<span class="ml-2 text-xs bg-amber-200 text-amber-800 px-1 rounded">adj</span>' : ''}
                                            </td>
                                            <td class="px-4 py-3 text-slate-600">${p.team}</td>
                                            <td class="px-4 py-3 text-center">${p.matchWins}</td>
                                            <td class="px-4 py-3 text-center">${p.matchLosses}</td>
                                            <td class="px-4 py-3 text-center">${p.gamesWon}</td>
                                            <td class="px-4 py-3 text-center">${p.gamesLost}</td>
                                            <td class="px-4 py-3 text-center font-bold text-emerald-700">${pct}%</td>
                                            ${editing ? `
                                                <td class="px-2 py-2">
                                                    <div class="flex gap-1 items-center text-xs">
                                                        <label class="text-gray-500">MW:</label>
                                                        <input type="number" 
                                                            value="${adj.matchWins || 0}" 
                                                            onchange="updatePlayerStatsAdjustment('${p.id}', 'matchWins', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                        <label class="text-gray-500 ml-1">ML:</label>
                                                        <input type="number" 
                                                            value="${adj.matchLosses || 0}" 
                                                            onchange="updatePlayerStatsAdjustment('${p.id}', 'matchLosses', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                        <label class="text-gray-500 ml-1">GW:</label>
                                                        <input type="number" 
                                                            value="${adj.gamesWon || 0}" 
                                                            onchange="updatePlayerStatsAdjustment('${p.id}', 'gamesWon', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                        <label class="text-gray-500 ml-1">GL:</label>
                                                        <input type="number" 
                                                            value="${adj.gamesLost || 0}" 
                                                            onchange="updatePlayerStatsAdjustment('${p.id}', 'gamesLost', this.value)"
                                                            class="w-12 px-1 py-1 border rounded text-center text-sm">
                                                    </div>
                                                </td>
                                            ` : ''}
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                    
                    ${editing ? `
                        <div class="bg-white rounded-xl shadow-lg p-4">
                            <h3 class="font-bold mb-3">Quick Adjustment by Team</h3>
                            <p class="text-sm text-gray-600 mb-3">Click buttons to quickly adjust match wins/losses:</p>
                            <div class="space-y-4">
                                ${Object.entries(teamGroups).map(([teamName, players]) => `
                                    <div class="border rounded-lg p-3">
                                        <h4 class="font-semibold text-emerald-700 mb-2">${teamName}</h4>
                                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-2">
                                            ${players.map(p => `
                                                <div class="flex items-center justify-between bg-slate-50 p-2 rounded">
                                                    <span class="text-sm font-medium">${p.name}</span>
                                                    <div class="flex gap-1">
                                                        <button onclick="quickPlayerAdjust('${p.id}', 1, 0)" class="px-2 py-1 bg-green-100 text-green-800 rounded text-xs hover:bg-green-200">+MW</button>
                                                        <button onclick="quickPlayerAdjust('${p.id}', -1, 0)" class="px-2 py-1 bg-red-100 text-red-800 rounded text-xs hover:bg-red-200">-MW</button>
                                                        <button onclick="quickPlayerAdjust('${p.id}', 0, 1)" class="px-2 py-1 bg-green-100 text-green-800 rounded text-xs hover:bg-green-200">+ML</button>
                                                        <button onclick="quickPlayerAdjust('${p.id}', 0, -1)" class="px-2 py-1 bg-red-100 text-red-800 rounded text-xs hover:bg-red-200">-ML</button>
                                                    </div>
                                                </div>
                                            `).join('')}
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderHistory() {
            const completed = state.schedule.filter(s => !s.isBye && state.matches.find(m => m.scheduleId === s.id)).sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Helper to get player name by ID
            const getPlayerName = (playerId) => {
                for (const team of state.teams) {
                    const player = (team.players || []).find(p => p.id === playerId);
                    if (player) return player.name;
                }
                return 'Unknown';
            };
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6">
                        <h2 class="text-3xl font-black">üìú History</h2>
                    </div>
                    ${completed.length === 0 ? '<div class="bg-white rounded-xl shadow-lg p-12 text-center text-slate-600">No completed matches</div>' : completed.map(sched => {
                        const match = state.matches.find(m => m.scheduleId === sched.id);
                        const home = state.teams.find(t => t.id === sched.homeTeamId);
                        const away = state.teams.find(t => t.id === sched.awayTeamId);
                        const isExpanded = state.selectedHistoryMatch === sched.id;
                        const matchups = match.matchups || [];
                        const isMarkedPlayed = match.markedPlayed;
                        
                        return `
                            <div class="bg-white rounded-xl shadow-lg overflow-hidden">
                                <div class="p-6 cursor-pointer hover:bg-slate-50 transition-colors" onclick="window.state.selectedHistoryMatch = window.state.selectedHistoryMatch === '${sched.id}' ? null : '${sched.id}'; window.render();">
                                    <div class="flex justify-between items-center">
                                        <div>
                                            <h3 class="text-xl font-bold">${away?.name} @ ${home?.name}</h3>
                                            <p class="text-slate-600">Week ${sched.week} ‚Ä¢ ${sched.date}</p>
                                        </div>
                                        <div class="flex items-center gap-4">
                                            ${isMarkedPlayed ? `
                                                <div class="text-lg font-bold text-slate-500">‚úì Played</div>
                                            ` : `
                                                <div class="text-3xl font-black text-emerald-700">${match.awayScore} - ${match.homeScore}</div>
                                            `}
                                            <span class="text-slate-400 text-xl">${isExpanded ? '‚ñ≤' : '‚ñº'}</span>
                                        </div>
                                    </div>
                                </div>
                                
                                ${isExpanded ? `
                                <div class="border-t bg-slate-50 p-6">
                                    <h4 class="font-bold text-slate-700 mb-4">Match Details</h4>
                                    ${isMarkedPlayed ? `
                                        <div class="text-center py-6">
                                            <div class="text-4xl mb-2">‚úì</div>
                                            <p class="text-slate-600 font-semibold">Match was marked as played</p>
                                            <p class="text-slate-500 text-sm">No detailed scores were recorded</p>
                                        </div>
                                    ` : matchups.length === 0 ? `
                                        <p class="text-slate-500 text-center py-4">No detailed matchup data available</p>
                                    ` : `
                                        <div class="space-y-3">
                                            ${matchups.map((mu, idx) => {
                                                const homePlayer = getPlayerName(mu.homePlayer);
                                                const awayPlayer = getPlayerName(mu.awayPlayer);
                                                const homeWon = parseInt(mu.homeGames) > parseInt(mu.awayGames);
                                                const awayWon = parseInt(mu.awayGames) > parseInt(mu.homeGames);
                                                return `
                                                    <div class="flex items-center justify-between p-3 bg-white rounded-lg border ${homeWon ? 'border-l-4 border-l-emerald-500' : awayWon ? 'border-r-4 border-r-emerald-500' : ''}">
                                                        <div class="flex-1 text-left">
                                                            <span class="${homeWon ? 'font-bold text-emerald-700' : 'text-slate-600'}">${homePlayer}</span>
                                                            <span class="text-xs text-slate-400 ml-1">(${home?.name})</span>
                                                        </div>
                                                        <div class="px-4 text-center">
                                                            <span class="font-mono font-bold text-lg ${homeWon ? 'text-emerald-600' : 'text-slate-400'}">${mu.homeGames || 0}</span>
                                                            <span class="text-slate-400 mx-2">-</span>
                                                            <span class="font-mono font-bold text-lg ${awayWon ? 'text-emerald-600' : 'text-slate-400'}">${mu.awayGames || 0}</span>
                                                        </div>
                                                        <div class="flex-1 text-right">
                                                            <span class="text-xs text-slate-400 mr-1">(${away?.name})</span>
                                                            <span class="${awayWon ? 'font-bold text-emerald-700' : 'text-slate-600'}">${awayPlayer}</span>
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                        
                                        <div class="mt-4 pt-4 border-t flex justify-between text-sm text-slate-600">
                                            <div>
                                                <span class="font-semibold">${home?.name}:</span> 
                                                ${matchups.filter(m => parseInt(m.homeGames) > parseInt(m.awayGames)).length} wins
                                            </div>
                                            <div>
                                                <span class="font-semibold">${away?.name}:</span> 
                                                ${matchups.filter(m => parseInt(m.awayGames) > parseInt(m.homeGames)).length} wins
                                            </div>
                                        </div>
                                    `}
                                </div>
                                ` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function renderTeams() {
            const isAdmin = state.currentUser.role === 'admin';
            const isCaptain = state.currentUser.role === 'captain';
            const isPlayer = state.currentUser.role === 'player';
            const myTeamId = state.currentUser.teamId;

            // Get captains not already assigned to a team
            const assignedCaptains = state.teams.map(t => t.captain).filter(c => c);
            const availableCaptains = state.users.filter(u => 
                u.role === 'captain' && !assignedCaptains.includes(u.email) && !assignedCaptains.includes(getUserDisplayName(u))
            );
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6">
                        <h2 class="text-3xl font-black">üè† Teams</h2>
                        ${isPlayer ? '<p class="opacity-90 mt-1">View team information</p>' : ''}
                    </div>

                    ${isAdmin ? `
                    <!-- Venue Management Section -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <button onclick="window.state.showManageVenues = !window.state.showManageVenues; window.render();" class="w-full bg-slate-600 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2">
                            üìç Manage Venues ${state.showManageVenues ? '‚ñ≤' : '‚ñº'}
                        </button>
                        ${state.showManageVenues ? `
                        <div class="mt-4 border-t pt-4">
                            <div class="space-y-2 mb-4 p-4 bg-slate-50 rounded-lg">
                                <input type="text" id="new-venue-name" placeholder="Venue name *" class="w-full px-4 py-2 border-2 rounded-lg">
                                <input type="text" id="new-venue-address" placeholder="Address" class="w-full px-4 py-2 border-2 rounded-lg">
                                <input type="tel" id="new-venue-phone" placeholder="Phone number" class="w-full px-4 py-2 border-2 rounded-lg">
                                <button onclick="handleAddVenue()" class="w-full px-6 py-2 bg-blue-600 text-white font-bold rounded-lg">Add Venue</button>
                            </div>
                            ${state.venues.length === 0 ? 
                                '<p class="text-slate-500 text-center py-4">No venues defined yet</p>' :
                                '<div class="space-y-2">' + state.venues.map(v => {
                                    const venue = typeof v === 'string' ? { name: v, address: '', phone: '' } : v;
                                    const phoneClean = venue.phone ? venue.phone.replace(/[^0-9+]/g, '') : '';
                                    const addressEncoded = venue.address ? encodeURIComponent(venue.address) : '';
                                    return `
                                    <div class="bg-slate-50 p-3 rounded border">
                                        <div class="flex justify-between items-start">
                                            <div>
                                                <div class="font-bold">üìç ${venue.name}</div>
                                                ${venue.address ? '<a href="https://maps.google.com/?q=' + addressEncoded + '" target="_blank" class="text-sm text-blue-600 hover:underline block">üè† ' + venue.address + '</a>' : ''}
                                                ${venue.phone ? '<a href="tel:' + phoneClean + '" class="text-sm text-blue-600 hover:underline block">üìû ' + venue.phone + '</a>' : ''}
                                            </div>
                                            <button onclick="deleteVenue('${venue.name.replace(/'/g, "\\'")}')" class="text-red-600 text-sm">‚ùå</button>
                                        </div>
                                    </div>
                                `}).join('') + '</div>'
                            }
                        </div>
                        ` : ''}
                    </div>

                    <!-- Create Team Section -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <button onclick="window.state.showCreateTeam = !window.state.showCreateTeam; window.render();" class="w-full bg-emerald-600 text-white font-bold py-3 rounded-lg">‚ûï Create Team</button>
                        ${state.showCreateTeam ? `
                        <div class="mt-4 space-y-3 border-t pt-4">
                            <div>
                                <label class="block text-sm font-bold mb-1">Team Name *</label>
                                <input type="text" id="team-name" placeholder="Enter team name" class="w-full px-4 py-2 border-2 rounded-lg">
                            </div>
                            <div>
                                <label class="block text-sm font-bold mb-1">Home Venue</label>
                                <select id="team-venue" class="w-full px-4 py-2 border-2 rounded-lg">
                                    <option value="">Select venue...</option>
                                    ${state.venues.map(v => {
                                        const venue = typeof v === 'string' ? { name: v } : v;
                                        return '<option value="' + venue.name + '">' + venue.name + '</option>';
                                    }).join('')}
                                </select>
                                ${state.venues.length === 0 ? '<p class="text-xs text-orange-600 mt-1">‚ö†Ô∏è Add venues above first</p>' : ''}
                            </div>
                            <div>
                                <label class="block text-sm font-bold mb-1">Captain</label>
                                <select id="team-captain" class="w-full px-4 py-2 border-2 rounded-lg">
                                    <option value="">Select captain...</option>
                                    ${availableCaptains.map(c => `<option value="${c.email}">${getUserDisplayName(c)}${c.phone ? ' (' + c.phone + ')' : ''}</option>`).join('')}
                                </select>
                                ${availableCaptains.length === 0 ? '<p class="text-xs text-orange-600 mt-1">‚ö†Ô∏è No available captains (create users or unassign existing)</p>' : ''}
                            </div>
                            <button onclick="handleCreateTeam()" class="w-full bg-blue-600 text-white font-bold py-2 rounded-lg">Create Team</button>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}

                    ${[...state.teams].sort((a, b) => a.name.localeCompare(b.name)).map(team => {
                        // Players can view but not edit, even their own team
                        const canEdit = isAdmin || (isCaptain && myTeamId === team.id);
                        const venueData = state.venues.find(v => (typeof v === 'string' ? v : v.name) === team.venue);
                        const venueObj = venueData ? (typeof venueData === 'string' ? { name: venueData } : venueData) : null;
                        const venuePhone = venueObj && venueObj.phone ? venueObj.phone.replace(/[^0-9+]/g, '') : '';
                        const venueAddress = venueObj && venueObj.address ? encodeURIComponent(venueObj.address) : '';
                        const sortedPlayers = [...team.players].sort((a, b) => a.name.localeCompare(b.name));
                        
                        return `
                        <div class="bg-white rounded-xl shadow-lg p-6 ${myTeamId === team.id ? 'border-2 border-emerald-400' : ''}">
                            <div class="flex justify-between items-start mb-4">
                                <div>
                                    <h3 class="text-2xl font-bold">${team.name} ${myTeamId === team.id ? '<span class="text-sm bg-emerald-100 text-emerald-800 px-2 py-1 rounded-full">Your Team</span>' : ''}</h3>
                                    <div class="text-slate-600">
                                        <span>üìç ${team.venue || 'No venue'}</span>
                                        ${venueObj && venueObj.address ? ' <a href="https://maps.google.com/?q=' + venueAddress + '" target="_blank" class="text-blue-600 hover:underline">(Map)</a>' : ''}
                                        ${venueObj && venueObj.phone ? ' <a href="tel:' + venuePhone + '" class="text-blue-600 hover:underline">(Call)</a>' : ''}
                                        <span> ‚Ä¢ üë§ <strong>${team.captain || 'No captain'}</strong></span>
                                    </div>
                                </div>
                                ${isAdmin ? `<button onclick="deleteTeam('${team.id}')" class="text-red-600">‚ùå</button>` : ''}
                            </div>
                            <div class="border-t pt-4">
                                <h4 class="font-bold mb-2">Players (${team.players.length})</h4>
                                <div class="grid sm:grid-cols-2 gap-2 mb-4">
                                    ${sortedPlayers.map(p => {
                                        const isCaptainPlayer = team.captain === p.name;
                                        return `
                                        <div class="flex justify-between items-center ${isCaptainPlayer ? 'bg-amber-50 border-amber-300' : 'bg-slate-50'} p-2 rounded border">
                                            <span>
                                                ${isCaptainPlayer ? 'üëë ' : ''}${p.name}
                                                ${isCaptainPlayer ? '<span class="text-xs text-amber-700 ml-1">(Captain)</span>' : ''}
                                            </span>
                                            ${canEdit ? `<button onclick="removePlayer('${team.id}', '${p.id}')" class="text-red-600 text-sm">‚ùå</button>` : ''}
                                        </div>
                                    `}).join('')}
                                </div>
                                ${canEdit ? `
                                <div class="flex gap-2 mb-4">
                                    <input type="text" id="player-${team.id}" placeholder="New player" class="flex-1 px-3 py-2 border rounded">
                                    <button onclick="handleAddPlayer('${team.id}')" class="px-4 py-2 bg-blue-600 text-white rounded font-bold">Add</button>
                                </div>
                                ` : ''}
                                ${isAdmin && team.players.length > 0 ? `
                                <div class="border-t pt-4 mt-4">
                                    <label class="block text-sm font-bold mb-2">üëë Set Team Captain</label>
                                    <div class="flex gap-2">
                                        <select id="captain-select-${team.id}" class="flex-1 px-3 py-2 border rounded">
                                            <option value="">Select captain...</option>
                                            ${sortedPlayers.map(p => `<option value="${p.name}" ${team.captain === p.name ? 'selected' : ''}>${p.name}</option>`).join('')}
                                        </select>
                                        <button onclick="setTeamCaptain('${team.id}')" class="px-4 py-2 bg-amber-500 text-white rounded font-bold hover:bg-amber-600">Set Captain</button>
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    `}).join('')}
                </div>
            `;
        }

        function renderUsers() {
            const isAdmin = state.currentUser.role === 'admin';
            const isCaptain = state.currentUser.role === 'captain';
            const myTeamId = state.currentUser.teamId;
            
            // Captains only see users on their team, admins see all
            const visibleUsers = isAdmin 
                ? state.users 
                : state.users.filter(u => u.teamId === myTeamId || u.id === state.currentUser.id);
            
            const myTeam = state.teams.find(t => t.id === myTeamId);
            const canCreateUsers = isAdmin || isCaptain;
            
            // Invite result modal (shown after creating user)
            const inviteModal = state.showInviteResult ? `
                <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div class="bg-white rounded-2xl shadow-2xl w-full max-w-lg">
                        <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white p-4 rounded-t-2xl">
                            <h3 class="text-xl font-bold">‚úÖ User Invited!</h3>
                        </div>
                        <div class="p-6 space-y-4">
                            <p class="text-slate-700">
                                <strong>${getUserDisplayName(state.showInviteResult.user)}</strong> has been added.
                            </p>
                            
                            ${state.showInviteResult.emailSent ? `
                                <div class="bg-green-50 border border-green-200 rounded-lg p-3 flex items-center gap-2">
                                    <span class="text-green-600 text-lg">‚úâÔ∏è</span>
                                    <div>
                                        <p class="text-green-800 font-medium text-sm">Invite email sent!</p>
                                        <p class="text-green-600 text-xs">Sent to ${state.showInviteResult.user.email}</p>
                                    </div>
                                </div>
                            ` : `
                                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 flex items-center gap-2">
                                    <span class="text-yellow-600 text-lg">‚ö†Ô∏è</span>
                                    <div>
                                        <p class="text-yellow-800 font-medium text-sm">Email not sent</p>
                                        <p class="text-yellow-600 text-xs">Share the link below manually</p>
                                    </div>
                                </div>
                            `}
                            
                            <p class="text-sm text-slate-600">
                                ${state.showInviteResult.emailSent ? 'Or share this link directly:' : 'Share this setup link with them:'}
                            </p>
                            <div class="bg-slate-100 p-3 rounded-lg">
                                <input type="text" readonly value="${state.showInviteResult.inviteUrl}" 
                                    id="invite-url-input"
                                    class="w-full bg-transparent text-sm text-slate-700 border-0 outline-none">
                            </div>
                            <div class="flex gap-2">
                                <button onclick="copyInviteLink()" class="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700">
                                    üìã Copy Link
                                </button>
                                <button onclick="sendInviteSMS()" class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg font-bold hover:bg-green-700">
                                    üì± Send SMS
                                </button>
                            </div>
                            <p class="text-xs text-slate-500 text-center">
                                The link is single-use and works until they set their password.
                            </p>
                            <button onclick="closeInviteModal()" class="w-full px-4 py-2 border-2 border-slate-300 rounded-lg font-bold text-slate-600 hover:bg-slate-50">
                                Done
                            </button>
                        </div>
                    </div>
                </div>
            ` : '';
            
            // Edit modal
            const editModal = state.editingUser ? `
                <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
                    <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md">
                        <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white p-4 rounded-t-2xl">
                            <h3 class="text-xl font-bold">‚úèÔ∏è Edit User</h3>
                        </div>
                        <div class="p-6 space-y-4">
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-sm font-bold text-slate-700 mb-1">First Name</label>
                                    <input type="text" id="edit-firstname" value="${state.editingUser.firstName}" 
                                        onchange="updateEditingUser('firstName', this.value)"
                                        class="w-full px-3 py-2 border-2 rounded-lg">
                                </div>
                                <div>
                                    <label class="block text-sm font-bold text-slate-700 mb-1">Last Name</label>
                                    <input type="text" id="edit-lastname" value="${state.editingUser.lastName}"
                                        onchange="updateEditingUser('lastName', this.value)"
                                        class="w-full px-3 py-2 border-2 rounded-lg">
                                </div>
                            </div>
                            <div>
                                <label class="block text-sm font-bold text-slate-700 mb-1">Email *</label>
                                <input type="email" id="edit-email" value="${state.editingUser.email}"
                                    onchange="updateEditingUser('email', this.value)"
                                    class="w-full px-3 py-2 border-2 rounded-lg">
                            </div>
                            <div>
                                <label class="block text-sm font-bold text-slate-700 mb-1">Phone *</label>
                                <input type="tel" id="edit-phone" value="${state.editingUser.phone}"
                                    onchange="updateEditingUser('phone', this.value)"
                                    class="w-full px-3 py-2 border-2 rounded-lg">
                            </div>
                            ${isAdmin ? `
                            <div>
                                <label class="block text-sm font-bold text-slate-700 mb-1">Role</label>
                                <select id="edit-role" onchange="updateEditingUser('role', this.value)"
                                    class="w-full px-3 py-2 border-2 rounded-lg">
                                    <option value="player" ${state.editingUser.role === 'player' ? 'selected' : ''}>Player</option>
                                    <option value="captain" ${state.editingUser.role === 'captain' ? 'selected' : ''}>Captain</option>
                                    <option value="admin" ${state.editingUser.role === 'admin' ? 'selected' : ''}>Admin</option>
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-bold text-slate-700 mb-1">Team</label>
                                <select id="edit-team" onchange="updateEditingUser('teamId', this.value)"
                                    class="w-full px-3 py-2 border-2 rounded-lg">
                                    <option value="">No team</option>
                                    ${[...state.teams].sort((a, b) => a.name.localeCompare(b.name)).map(t => 
                                        `<option value="${t.id}" ${state.editingUser.teamId === t.id ? 'selected' : ''}>${t.name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            ` : ''}
                            <div class="flex gap-3 pt-4">
                                <button onclick="cancelEditUser()" class="flex-1 px-4 py-2 border-2 border-slate-300 rounded-lg font-bold text-slate-600 hover:bg-slate-50">
                                    Cancel
                                </button>
                                <button onclick="saveUser()" class="flex-1 px-4 py-2 bg-emerald-600 text-white rounded-lg font-bold hover:bg-emerald-700">
                                    Save Changes
                                </button>
                            </div>
                            ${isAdmin && state.editingUser.id !== state.currentUser.id ? `
                            <div class="pt-4 border-t flex gap-2">
                                <button onclick="handleResendInvite('${state.editingUser.id}')" class="flex-1 px-3 py-2 bg-blue-500 text-white rounded-lg text-sm font-bold hover:bg-blue-600">
                                    üìß Resend Invite
                                </button>
                                <button onclick="resetPassword('${state.editingUser.id}')" class="flex-1 px-3 py-2 bg-yellow-500 text-white rounded-lg text-sm font-bold hover:bg-yellow-600">
                                    üîë Reset Password
                                </button>
                            </div>
                            <div class="pt-2">
                                <button onclick="if(confirm('Delete this user?')) { deleteUser('${state.editingUser.id}'); cancelEditUser(); }" class="w-full px-3 py-2 bg-red-600 text-white rounded-lg text-sm font-bold hover:bg-red-700">
                                    üóëÔ∏è Delete User
                                </button>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
            ` : '';
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6">
                        <h2 class="text-3xl font-black">üë• ${isCaptain ? 'Team Members' : 'Users'}</h2>
                        ${isCaptain && myTeam ? '<p class="opacity-90 mt-1">' + myTeam.name + '</p>' : ''}
                    </div>

                    ${canCreateUsers ? `
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <button onclick="document.getElementById('create-user-form').classList.toggle('hidden')" class="w-full bg-emerald-600 text-white font-bold py-3 rounded-lg">‚ûï ${isCaptain ? 'Invite Team Member' : 'Invite User'}</button>
                        <div id="create-user-form" class="hidden mt-4 space-y-3 border-t pt-4">
                            <p class="text-sm text-slate-600">They'll receive a link to set up their password.</p>
                            <div class="grid grid-cols-2 gap-2">
                                <input type="text" id="new-firstname" placeholder="First Name" class="w-full px-4 py-2 border-2 rounded-lg">
                                <input type="text" id="new-lastname" placeholder="Last Name" class="w-full px-4 py-2 border-2 rounded-lg">
                            </div>
                            <input type="email" id="new-email" placeholder="Email *" class="w-full px-4 py-2 border-2 rounded-lg">
                            <input type="tel" id="new-phone" placeholder="Phone *" class="w-full px-4 py-2 border-2 rounded-lg">
                            ${isAdmin ? `
                                <select id="new-user-role" class="w-full px-4 py-2 border-2 rounded-lg">
                                    <option value="player">Player (view only)</option>
                                    <option value="captain">Captain (can submit scores)</option>
                                    <option value="admin">Admin (full access)</option>
                                </select>
                                <select id="new-user-team" class="w-full px-4 py-2 border-2 rounded-lg">
                                    <option value="">No team</option>
                                    ${[...state.teams].sort((a, b) => a.name.localeCompare(b.name)).map(t => `<option value="${t.id}">${t.name}</option>`).join('')}
                                </select>
                            ` : `<p class="text-xs text-slate-500">New member will be added to your team as a player</p>`}
                            <button onclick="handleCreateUser()" class="w-full bg-blue-600 text-white font-bold py-2 rounded-lg">Send Invite</button>
                        </div>
                    </div>
                    ` : ''}

                    <div class="bg-white rounded-xl shadow-lg divide-y">
                        ${visibleUsers.length === 0 ? '<p class="p-6 text-slate-500 text-center">No team members found</p>' : ''}
                        ${visibleUsers.map(user => {
                            const team = state.teams.find(t => t.id === user.teamId);
                            const roleIcon = user.role === 'admin' ? 'üõ°Ô∏è' : (user.role === 'captain' ? '¬©Ô∏è' : 'üë§');
                            const displayName = getUserDisplayName(user);
                            const canEdit = isAdmin || user.id === state.currentUser.id || (isCaptain && user.teamId === myTeamId);
                            const isPending = user.status === 'pending' || user.inviteToken;
                            return `
                            <div onclick="${canEdit ? `editUser('${user.id}')` : ''}" 
                                class="p-4 flex items-center gap-4 ${user.id === state.currentUser.id ? 'bg-emerald-50' : ''} ${canEdit ? 'cursor-pointer hover:bg-slate-50' : ''}">
                                <div class="text-3xl">${roleIcon}</div>
                                <div class="flex-1">
                                    <div class="font-bold flex items-center gap-2 flex-wrap">
                                        ${displayName} 
                                        ${user.id === state.currentUser.id ? '<span class="text-xs bg-emerald-600 text-white px-2 py-0.5 rounded-full">You</span>' : ''}
                                        ${isPending ? '<span class="text-xs bg-yellow-100 text-yellow-700 px-2 py-0.5 rounded-full">‚è≥ Pending</span>' : ''}
                                        ${canEdit ? '<span class="text-xs text-blue-500">‚úèÔ∏è</span>' : ''}
                                    </div>
                                    <div class="text-sm text-slate-500">${user.email || ''}</div>
                                    <div class="text-sm text-slate-600">${user.role} ${team ? '‚Ä¢ ' + team.name : ''}</div>
                                    ${user.phone ? '<div class="text-sm"><span class="text-blue-600">üìû ' + user.phone + '</span></div>' : ''}
                                </div>
                            </div>
                        `}).join('')}
                    </div>
                </div>
                ${editModal}
                ${inviteModal}
            `;
        }

        function renderAdmin() {
            const conflicts = [];
            const grouped = {};
            state.submissions.forEach(s => {
                if (!grouped[s.scheduleId]) grouped[s.scheduleId] = [];
                grouped[s.scheduleId].push(s);
            });
            Object.entries(grouped).forEach(([schedId, subs]) => {
                if (subs.length === 2 && (subs[0].homeScore !== subs[1].homeScore || subs[0].awayScore !== subs[1].awayScore)) {
                    conflicts.push({ scheduleId: schedId, submissions: subs });
                }
            });

            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6">
                        <h2 class="text-3xl font-black">üõ°Ô∏è Admin</h2>
                    </div>

                    <div class="grid md:grid-cols-3 gap-4">
                        <div class="bg-white rounded-xl shadow-lg p-6 text-center">
                            <div class="text-4xl font-black text-blue-600">${state.users.length}</div>
                            <div class="text-slate-600">Users</div>
                        </div>
                        <div class="bg-white rounded-xl shadow-lg p-6 text-center">
                            <div class="text-4xl font-black text-emerald-600">${state.teams.length}</div>
                            <div class="text-slate-600">Teams</div>
                        </div>
                        <div class="bg-white rounded-xl shadow-lg p-6 text-center">
                            <div class="text-4xl font-black text-purple-600">${state.matches.length}</div>
                            <div class="text-slate-600">Matches</div>
                        </div>
                    </div>

                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-xl font-bold mb-4">‚ö†Ô∏è Conflicts (${conflicts.length})</h3>
                        ${conflicts.length === 0 ? '<p class="text-slate-600">No conflicts</p>' : conflicts.map(c => {
                            const sched = state.schedule.find(s => s.id === c.scheduleId);
                            const home = state.teams.find(t => t.id === sched?.homeTeamId);
                            const away = state.teams.find(t => t.id === sched?.awayTeamId);
                            return `
                                <div class="border-2 border-red-200 rounded-lg p-4 mb-4 bg-red-50">
                                    <h4 class="font-bold">Week ${sched?.week}: ${away?.name} @ ${home?.name}</h4>
                                    <div class="grid grid-cols-2 gap-4 mt-2">
                                        ${c.submissions.map((sub, i) => {
                                            const team = state.teams.find(t => t.id === sub.teamId);
                                            return `
                                                <div class="bg-white p-3 rounded border">
                                                    <div class="font-semibold">${team?.name}:</div>
                                                    <div class="text-2xl font-bold">${sub.awayScore} - ${sub.homeScore}</div>
                                                    <button onclick="approveSubmission('${c.scheduleId}', ${i})" class="mt-2 px-3 py-1 bg-emerald-600 text-white rounded text-sm">Approve</button>
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                    <button onclick="rejectBoth('${c.scheduleId}')" class="mt-3 px-4 py-2 bg-red-600 text-white rounded w-full">Reject Both</button>
                                </div>
                            `;
                        }).join('')}
                    </div>

                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <button onclick="clearAllData()" class="w-full bg-red-600 text-white font-bold py-3 rounded-lg">üóëÔ∏è Clear All Data</button>
                    </div>
                </div>
            `;
        }

        // ============================================
        // PDF SCORESHEET GENERATION
        // ============================================
        function generateScoresheetPDF(numSheets = 2) {
            // Uses jsPDF library loaded dynamically
            if (!window.jspdf) {
                alert('PDF library loading... please try again in a moment.');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('portrait', 'pt', 'letter');
            const width = doc.internal.pageSize.getWidth();
            const height = doc.internal.pageSize.getHeight();
            const halfHeight = height / 2;
            
            const leagueName = state.leagueName;
            
            // Colors
            const green = [16, 185, 129];
            const dark = [30, 41, 59];
            const lightGray = [241, 245, 249];
            
            function drawScoresheet(yOffset) {
                // Header
                doc.setFillColor(...green);
                doc.rect(0, yOffset, width, 35, 'F');
                
                doc.setTextColor(255, 255, 255);
                doc.setFontSize(16);
                doc.setFont('helvetica', 'bold');
                doc.text(leagueName, width / 2, yOffset + 23, { align: 'center' });
                
                // Date & Teams
                let y = yOffset + 55;
                doc.setTextColor(...dark);
                doc.setFontSize(8);
                doc.setFont('helvetica', 'normal');
                doc.text('Date: _________', 30, y);
                
                doc.setFontSize(10);
                doc.setFont('helvetica', 'bold');
                doc.text('HOME:', 140, y);
                doc.setLineWidth(0.5);
                doc.line(180, y + 2, 300, y + 2);
                
                doc.text('AWAY:', 340, y);
                doc.line(380, y + 2, 500, y + 2);
                
                // Games table header
                y = yOffset + 85;
                doc.setFontSize(8);
                doc.text('#', 32, y);
                doc.text('HOME PLAYER', 115, y, { align: 'center' });
                doc.text('AWAY PLAYER', 325, y, { align: 'center' });
                
                y += 5;
                doc.setDrawColor(...green);
                doc.setLineWidth(1.5);
                doc.line(25, y, width - 25, y);
                
                y += 8;
                
                // Game rows
                const boxSize = 14;
                const rowHeight = 28;
                
                for (let game = 1; game <= 5; game++) {
                    // Alternating background
                    if (game % 2 === 1) {
                        doc.setFillColor(...lightGray);
                        doc.rect(25, y - 5, width - 50, rowHeight, 'F');
                    }
                    
                    // Game number
                    doc.setTextColor(...green);
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'bold');
                    doc.text(String(game), 35, y + 12);
                    
                    // Home player line
                    doc.setDrawColor(...dark);
                    doc.setLineWidth(0.5);
                    doc.line(50, y + 15, 155, y + 15);
                    
                    // Home boxes
                    doc.setLineWidth(1);
                    doc.rect(165, y + 1, boxSize, boxSize);
                    doc.rect(165 + boxSize + 4, y + 1, boxSize, boxSize);
                    
                    // Away player line
                    doc.setLineWidth(0.5);
                    doc.line(260, y + 15, 365, y + 15);
                    
                    // Away boxes
                    doc.setLineWidth(1);
                    doc.rect(375, y + 1, boxSize, boxSize);
                    doc.rect(375 + boxSize + 4, y + 1, boxSize, boxSize);
                    
                    y += rowHeight;
                }
                
                // Footer
                doc.setTextColor(150, 150, 150);
                doc.setFontSize(6);
                doc.setFont('helvetica', 'normal');
                doc.text('Mark X for each game won. First to 2 wins the match.', width / 2, yOffset + halfHeight - 10, { align: 'center' });
            }
            
            // Generate pages with 2 scoresheets each
            const pagesNeeded = Math.ceil(numSheets / 2);
            
            for (let page = 0; page < pagesNeeded; page++) {
                if (page > 0) doc.addPage();
                
                // Top scoresheet
                drawScoresheet(0);
                
                // Dashed cut line
                doc.setDrawColor(150, 150, 150);
                doc.setLineWidth(0.5);
                doc.setLineDashPattern([6, 3], 0);
                doc.line(20, halfHeight, width - 20, halfHeight);
                doc.setLineDashPattern([], 0);
                
                // Bottom scoresheet (if needed)
                if ((page * 2) + 1 < numSheets) {
                    drawScoresheet(halfHeight);
                }
            }
            
            doc.save(`${leagueName.replace(/[^a-z0-9]/gi, '_')}_Scoresheets.pdf`);
        }
        
        window.printScoresheet = function(count) {
            generateScoresheetPDF(count);
        };

        // ============================================
        // OCR SCORESHEET SCANNING
        // ============================================
        let ocrProgress = 0;
        let ocrStatus = '';
        
        async function scanScoresheet(file) {
            if (!file) return;
            
            showLoading();
            ocrStatus = 'Initializing OCR...';
            render();
            
            try {
                const worker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            ocrProgress = Math.round(m.progress * 100);
                            ocrStatus = `Reading scoresheet... ${ocrProgress}%`;
                        }
                    }
                });
                
                ocrStatus = 'Reading scoresheet...';
                const { data: { text } } = await worker.recognize(file);
                await worker.terminate();
                
                console.log('OCR Raw Text:', text);
                
                // Parse the scoresheet
                const result = parseScoresheetText(text);
                console.log('Parsed Result:', result);
                
                if (result.success) {
                    // Try to match teams
                    const homeTeam = findTeamByName(result.homeTeam);
                    const awayTeam = findTeamByName(result.awayTeam);
                    
                    if (homeTeam && awayTeam) {
                        // Find the matching scheduled match
                        const scheduledMatch = state.schedule.find(m => 
                            !m.isBye && 
                            m.homeTeamId === homeTeam.id && 
                            m.awayTeamId === awayTeam.id &&
                            !state.matches.find(x => x.scheduleId === m.id)
                        );
                        
                        if (scheduledMatch) {
                            state.selectedMatch = scheduledMatch.id;
                        }
                        
                        // Match players and fill in scores
                        for (let i = 0; i < 5; i++) {
                            if (result.games[i]) {
                                const game = result.games[i];
                                
                                // Find home player
                                const homePlayer = findPlayerByName(homeTeam, game.homePlayer);
                                if (homePlayer) {
                                    state.matchups[i].homePlayer = homePlayer.id;
                                }
                                state.matchups[i].homeGames = game.homeWins.toString();
                                
                                // Find away player
                                const awayPlayer = findPlayerByName(awayTeam, game.awayPlayer);
                                if (awayPlayer) {
                                    state.matchups[i].awayPlayer = awayPlayer.id;
                                }
                                state.matchups[i].awayGames = game.awayWins.toString();
                            }
                        }
                        
                        alert(`Scoresheet scanned!\n\nHome: ${homeTeam.name}\nAway: ${awayTeam.name}\n\nPlease review and correct any errors before submitting.`);
                    } else {
                        alert(`Could not match teams.\n\nRead: "${result.homeTeam}" vs "${result.awayTeam}"\n\nPlease select the match manually and review the player names.`);
                    }
                } else {
                    alert('Could not read scoresheet clearly. Please try again with a clearer photo, or enter scores manually.');
                }
                
            } catch (error) {
                console.error('OCR Error:', error);
                alert('Error scanning scoresheet. Please try again or enter scores manually.');
            } finally {
                hideLoading();
                ocrStatus = '';
                ocrProgress = 0;
                render();
            }
        }
        
        function parseScoresheetText(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
            console.log('Lines:', lines);
            
            const result = {
                success: false,
                homeTeam: '',
                awayTeam: '',
                games: []
            };
            
            // Look for HOME: and AWAY: patterns
            for (const line of lines) {
                const homeMatch = line.match(/HOME[:\s]+([A-Za-z0-9\s']+?)(?=\s*AWAY|$)/i);
                const awayMatch = line.match(/AWAY[:\s]+([A-Za-z0-9\s']+?)$/i);
                
                if (homeMatch) result.homeTeam = homeMatch[1].trim();
                if (awayMatch) result.awayTeam = awayMatch[1].trim();
            }
            
            // Also try to find teams on separate lines
            if (!result.homeTeam || !result.awayTeam) {
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].match(/^HOME/i) && lines[i+1]) {
                        result.homeTeam = result.homeTeam || lines[i].replace(/^HOME[:\s]*/i, '').trim();
                    }
                    if (lines[i].match(/^AWAY/i)) {
                        result.awayTeam = result.awayTeam || lines[i].replace(/^AWAY[:\s]*/i, '').trim();
                    }
                }
            }
            
            // Parse game rows - look for patterns like "1 PlayerName XX PlayerName XX"
            // where X can be a mark or empty
            for (let gameNum = 1; gameNum <= 5; gameNum++) {
                const game = {
                    homePlayer: '',
                    homeWins: 0,
                    awayPlayer: '',
                    awayWins: 0
                };
                
                // Find line starting with game number
                for (const line of lines) {
                    if (line.match(new RegExp(`^${gameNum}\\s`))) {
                        // Try to parse: "1 Name [X][X] Name [X][X]"
                        // This is tricky because OCR might read X marks differently
                        
                        const parts = line.substring(1).trim();
                        
                        // Count X marks or similar characters that indicate wins
                        const xMarks = (parts.match(/[xX‚úì‚úó‚òë‚òí]/g) || []).length;
                        
                        // Try to extract player names (words before/after the X marks)
                        const words = parts.split(/\s+/).filter(w => !w.match(/^[xX‚úì‚úó‚òë‚òí\[\]]+$/));
                        
                        // Heuristic: first half of words = home player, second half = away player
                        if (words.length >= 2) {
                            const midpoint = Math.floor(words.length / 2);
                            game.homePlayer = words.slice(0, midpoint).join(' ');
                            game.awayPlayer = words.slice(midpoint).join(' ');
                        }
                        
                        // Count wins based on X position (this is approximate)
                        // We'll look for patterns of marks
                        const homeSection = parts.substring(0, parts.length / 2);
                        const awaySection = parts.substring(parts.length / 2);
                        
                        game.homeWins = (homeSection.match(/[xX‚úì‚òë]/g) || []).length;
                        game.awayWins = (awaySection.match(/[xX‚úì‚òë]/g) || []).length;
                        
                        // Normalize to valid scores (0, 1, or 2)
                        game.homeWins = Math.min(2, game.homeWins);
                        game.awayWins = Math.min(2, game.awayWins);
                        
                        break;
                    }
                }
                
                result.games.push(game);
            }
            
            result.success = !!(result.homeTeam || result.awayTeam || result.games.some(g => g.homePlayer || g.awayPlayer));
            
            return result;
        }
        
        function findTeamByName(name) {
            if (!name) return null;
            const searchName = name.toLowerCase().trim();
            
            // Exact match
            let team = state.teams.find(t => t.name.toLowerCase() === searchName);
            if (team) return team;
            
            // Partial match
            team = state.teams.find(t => 
                t.name.toLowerCase().includes(searchName) || 
                searchName.includes(t.name.toLowerCase())
            );
            if (team) return team;
            
            // Fuzzy match - check if most words match
            const searchWords = searchName.split(/\s+/);
            for (const t of state.teams) {
                const teamWords = t.name.toLowerCase().split(/\s+/);
                const matches = searchWords.filter(sw => 
                    teamWords.some(tw => tw.includes(sw) || sw.includes(tw))
                );
                if (matches.length >= Math.min(searchWords.length, teamWords.length) * 0.5) {
                    return t;
                }
            }
            
            return null;
        }
        
        function findPlayerByName(team, name) {
            if (!team || !name) return null;
            const searchName = name.toLowerCase().trim();
            
            // Exact match
            let player = team.players.find(p => p.name.toLowerCase() === searchName);
            if (player) return player;
            
            // Partial match
            player = team.players.find(p => 
                p.name.toLowerCase().includes(searchName) || 
                searchName.includes(p.name.toLowerCase())
            );
            if (player) return player;
            
            // First/last name match
            const searchParts = searchName.split(/\s+/);
            for (const p of team.players) {
                const playerParts = p.name.toLowerCase().split(/\s+/);
                if (searchParts.some(sp => playerParts.some(pp => pp === sp || pp.startsWith(sp) || sp.startsWith(pp)))) {
                    return p;
                }
            }
            
            return null;
        }
        
        window.handleScoresheetUpload = function(input) {
            if (input.files && input.files[0]) {
                scanScoresheet(input.files[0]);
            }
        };

        function renderSettings() {
            // Get subscription info
            const org = state.organization;
            const subStatus = org?.subscriptionStatus || 'trial';
            const subTier = org?.subscriptionTier || 'trial';
            const trialEndsAt = org?.trialEndsAt ? new Date(org.trialEndsAt) : null;
            const daysLeft = trialEndsAt ? Math.ceil((trialEndsAt - new Date()) / (1000 * 60 * 60 * 24)) : 0;
            
            return `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 text-white rounded-xl shadow-lg p-6">
                        <h2 class="text-3xl font-black">‚öôÔ∏è Settings</h2>
                    </div>
                    
                    <!-- Subscription Section -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-lg font-bold mb-4">üí≥ Subscription</h3>
                        ${subStatus === 'trial' ? `
                        <div class="p-4 rounded-lg ${daysLeft <= 3 ? 'bg-red-50 border-2 border-red-200' : 'bg-yellow-50 border-2 border-yellow-200'}">
                            <div class="flex items-center gap-3">
                                <span class="text-2xl">${daysLeft <= 3 ? '‚ö†Ô∏è' : '‚è∞'}</span>
                                <div>
                                    <p class="font-bold ${daysLeft <= 3 ? 'text-red-800' : 'text-yellow-800'}">
                                        ${daysLeft <= 0 ? 'Your free trial has expired' : `Free Trial - ${daysLeft} days remaining`}
                                    </p>
                                    <p class="text-sm ${daysLeft <= 3 ? 'text-red-700' : 'text-yellow-700'}">
                                        ${daysLeft <= 0 ? 'Upgrade now to continue using Pool League Manager' : 'Upgrade anytime to unlock all features'}
                                    </p>
                                </div>
                            </div>
                            <a href="pricing.html" class="mt-4 block w-full py-3 bg-emerald-600 text-white text-center font-bold rounded-lg hover:bg-emerald-700">
                                Upgrade Now ‚Üí
                            </a>
                        </div>
                        ` : subStatus === 'active' ? `
                        <div class="p-4 bg-emerald-50 border-2 border-emerald-200 rounded-lg">
                            <div class="flex items-center gap-3">
                                <span class="text-2xl">‚úÖ</span>
                                <div>
                                    <p class="font-bold text-emerald-800">
                                        ${subTier.charAt(0).toUpperCase() + subTier.slice(1)} Plan - Active
                                    </p>
                                    <p class="text-sm text-emerald-700">Thank you for subscribing!</p>
                                </div>
                            </div>
                            <a href="pricing.html" class="mt-4 block w-full py-3 bg-slate-600 text-white text-center font-bold rounded-lg hover:bg-slate-700">
                                Manage Subscription ‚Üí
                            </a>
                        </div>
                        ` : `
                        <div class="p-4 bg-red-50 border-2 border-red-200 rounded-lg">
                            <div class="flex items-center gap-3">
                                <span class="text-2xl">‚ùå</span>
                                <div>
                                    <p class="font-bold text-red-800">Subscription Expired</p>
                                    <p class="text-sm text-red-700">Renew to continue using Pool League Manager</p>
                                </div>
                            </div>
                            <a href="pricing.html" class="mt-4 block w-full py-3 bg-emerald-600 text-white text-center font-bold rounded-lg hover:bg-emerald-700">
                                Renew Subscription ‚Üí
                            </a>
                        </div>
                        `}
                    </div>
                    
                    <!-- Season Management -->
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <button onclick="window.state.showManageSeasons = !window.state.showManageSeasons; window.render();" class="w-full bg-purple-600 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2">
                            üìÖ Manage Seasons ${state.showManageSeasons ? '‚ñ≤' : '‚ñº'}
                        </button>
                        ${state.showManageSeasons ? `
                        <div class="mt-4 border-t pt-4">
                            <div class="flex gap-2 mb-4">
                                <input type="text" id="new-season-name" placeholder="New season name (e.g., Fall 2025)" class="flex-1 px-4 py-2 border-2 rounded-lg">
                                <button onclick="handleCreateSeason()" class="px-6 py-2 bg-purple-600 text-white font-bold rounded-lg">Create</button>
                            </div>
                            ${state.seasons.length === 0 ? 
                                '<p class="text-slate-500 text-center py-4">No seasons yet. Create one to get started!</p>' :
                                '<div class="space-y-2">' + state.seasons.map(s => `
                                    <div class="flex justify-between items-center p-3 rounded border ${s.isActive ? 'bg-yellow-50 border-yellow-300' : 'bg-slate-50'}">
                                        <div>
                                            <span class="font-bold">${s.name}</span>
                                            ${s.isActive ? '<span class="ml-2 text-xs bg-yellow-400 text-yellow-900 px-2 py-0.5 rounded-full">Active</span>' : ''}
                                        </div>
                                        <div class="flex gap-2">
                                            ${!s.isActive ? `<button onclick="setActiveSeason('${s.id}')" class="text-xs px-3 py-1 bg-green-600 text-white rounded">Set Active</button>` : ''}
                                            <button onclick="confirmDeleteSeason('${s.id}', '${s.name.replace(/'/g, "\\'")}')" class="text-red-600 text-sm">‚ùå</button>
                                        </div>
                                    </div>
                                `).join('') + '</div>'
                            }
                            <p class="text-xs text-slate-500 mt-4">üí° The active season is the default for new schedules and scores. You can view historical seasons by selecting them in the header dropdown.</p>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <label class="block text-sm font-bold mb-2">League Name</label>
                        <input type="text" id="league-name" value="${state.leagueName}" class="w-full px-4 py-2 border-2 rounded-lg mb-4">
                        <button onclick="handleSaveSettings()" class="w-full bg-emerald-600 text-white font-bold py-3 rounded-lg">Save</button>
                    </div>
                    
                    <div class="bg-white rounded-xl shadow-lg p-6">
                        <h3 class="text-lg font-bold mb-4">üìÑ Print Scoresheets</h3>
                        <p class="text-sm text-slate-600 mb-4">Generate printable scoresheets with your league name. Half-page size (2 per sheet).</p>
                        <div class="flex gap-3 flex-wrap">
                            <button onclick="printScoresheet(2)" class="px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">
                                1 Page (2 sheets)
                            </button>
                            <button onclick="printScoresheet(10)" class="px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">
                                5 Pages (10 sheets)
                            </button>
                            <button onclick="printScoresheet(20)" class="px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700">
                                10 Pages (20 sheets)
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // ============================================
        // EVENT HANDLERS (attach to window for onclick)
        // ============================================
        window.handleLogin = async function() {
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;

            if (!email || !password) {
                document.getElementById('login-error').textContent = 'Please enter email and password';
                document.getElementById('login-error').classList.remove('hidden');
                return;
            }

            if (!await login(email, password)) {
                document.getElementById('login-error').textContent = 'Invalid credentials';
                document.getElementById('login-error').classList.remove('hidden');
            }
        };

        window.handleCreateUser = async function() {
            const firstName = document.getElementById('new-firstname').value;
            const lastName = document.getElementById('new-lastname').value;
            const email = document.getElementById('new-email').value;
            const phone = document.getElementById('new-phone').value;
            
            // Admins can pick role and team, captains create players for their team
            const roleSelect = document.getElementById('new-user-role');
            const teamSelect = document.getElementById('new-user-team');
            
            let role = null;
            let teamId = null;
            
            if (roleSelect && teamSelect) {
                // Admin - use selected role and team
                role = roleSelect.value || 'player';
                teamId = teamSelect.value || null;
            } else if (state.currentUser.role === 'captain') {
                // Captain - create player for their team
                role = 'player';
                teamId = state.currentUser.teamId;
            }
            
            // Use invite system - no password needed
            const result = await inviteUser(email, phone, role, teamId, firstName, lastName);
            
            if (result) {
                document.getElementById('new-firstname').value = '';
                document.getElementById('new-lastname').value = '';
                document.getElementById('new-email').value = '';
                document.getElementById('new-phone').value = '';
                if (roleSelect) roleSelect.value = 'player';
                if (teamSelect) teamSelect.value = '';
                document.getElementById('create-user-form').classList.add('hidden');
                
                // Show invite link modal
                state.showInviteResult = result;
                render();
            }
        };

        window.handleCreateTeam = async function() {
            await createTeam(
                document.getElementById('team-name').value,
                document.getElementById('team-venue').value,
                document.getElementById('team-captain').value
            );
        };

        window.handleAddVenue = async function() {
            const nameInput = document.getElementById('new-venue-name');
            const addressInput = document.getElementById('new-venue-address');
            const phoneInput = document.getElementById('new-venue-phone');
            if (await addVenue(nameInput.value, addressInput.value, phoneInput.value)) {
                nameInput.value = '';
                addressInput.value = '';
                phoneInput.value = '';
            }
        };

        window.handleAddPlayer = async function(teamId) {
            const input = document.getElementById('player-' + teamId);
            if (input.value.trim()) {
                await addPlayer(teamId, input.value);
                input.value = '';
            }
        };

        window.handleSaveSettings = async function() {
            await saveLeagueName(document.getElementById('league-name').value);
            alert('Saved!');
        };

        // Password reset handlers
        window.resetPassword = resetPassword;
        
        window.showResetForm = function() {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('signup-form')?.classList.add('hidden');
            document.getElementById('reset-form').classList.remove('hidden');
        };
        
        window.showLoginForm = function() {
            document.getElementById('reset-form').classList.add('hidden');
            document.getElementById('signup-form')?.classList.add('hidden');
            document.getElementById('login-form').classList.remove('hidden');
        };
        
        window.showSignupForm = function() {
            document.getElementById('login-form').classList.add('hidden');
            document.getElementById('reset-form').classList.add('hidden');
            document.getElementById('signup-form').classList.remove('hidden');
        };
        
        window.handleSelfReset = async function() {
            const email = document.getElementById('reset-email').value;
            const phone = document.getElementById('reset-phone').value;
            if (await selfServiceReset(email, phone)) {
                document.getElementById('reset-email').value = '';
                document.getElementById('reset-phone').value = '';
                showLoginForm();
            }
        };
        
        window.handleSignup = async function() {
            const orgName = document.getElementById('signup-org-name').value.trim();
            const firstName = document.getElementById('signup-firstname').value.trim();
            const lastName = document.getElementById('signup-lastname').value.trim();
            const email = document.getElementById('signup-email').value.trim();
            const phone = document.getElementById('signup-phone').value.trim();
            const password = document.getElementById('signup-password').value;
            const password2 = document.getElementById('signup-password2').value;
            const errorEl = document.getElementById('signup-error');
            
            // Validation
            if (!orgName) {
                errorEl.textContent = 'Organization name is required';
                errorEl.classList.remove('hidden');
                return;
            }
            if (!email) {
                errorEl.textContent = 'Email is required';
                errorEl.classList.remove('hidden');
                return;
            }
            if (!phone || phone.replace(/\D/g, '').length < 10) {
                errorEl.textContent = 'Valid phone number required (10+ digits)';
                errorEl.classList.remove('hidden');
                return;
            }
            if (!password || password.length < 4) {
                errorEl.textContent = 'Password must be at least 4 characters';
                errorEl.classList.remove('hidden');
                return;
            }
            if (password !== password2) {
                errorEl.textContent = 'Passwords do not match';
                errorEl.classList.remove('hidden');
                return;
            }
            
            showLoading();
            try {
                // Check if email already exists
                const { data: existingUsers } = await db.from('users').select('id').eq('email', email).limit(1);
                if (existingUsers && existingUsers.length > 0) {
                    errorEl.textContent = 'Email already registered. Please sign in.';
                    errorEl.classList.remove('hidden');
                    hideLoading();
                    return;
                }
                
                // Create organization with 14-day trial
                const trialEnds = new Date();
                trialEnds.setDate(trialEnds.getDate() + 14);
                
                const { data: newOrg, error: orgError } = await db.from('organizations').insert({
                    name: orgName,
                    subscription_tier: 'trial',
                    subscription_status: 'trial',
                    trial_ends_at: trialEnds.toISOString()
                }).select().single();
                
                if (orgError) throw orgError;
                
                // Create admin user
                const { data: newUser, error: userError } = await db.from('users').insert({
                    email: email,
                    password: password,
                    phone: phone,
                    first_name: firstName || null,
                    last_name: lastName || null,
                    role: 'admin',
                    org_id: newOrg.id
                }).select().single();
                
                if (userError) throw userError;
                
                // Create org_membership if table exists
                try {
                    await db.from('org_memberships').insert({
                        user_id: newUser.id,
                        org_id: newOrg.id,
                        role: 'owner'
                    });
                } catch (e) {
                    // org_memberships table might not exist yet, that's ok
                    console.log('org_memberships table not found, skipping');
                }
                
                alert(`Welcome to Pool League Manager! üéâ\n\nYour organization "${orgName}" has been created with a 14-day free trial.\n\nYou can now sign in with your email and password.`);
                
                // Clear form and switch to login
                document.getElementById('signup-org-name').value = '';
                document.getElementById('signup-firstname').value = '';
                document.getElementById('signup-lastname').value = '';
                document.getElementById('signup-email').value = '';
                document.getElementById('signup-phone').value = '';
                document.getElementById('signup-password').value = '';
                document.getElementById('signup-password2').value = '';
                errorEl.classList.add('hidden');
                
                // Pre-fill login email
                showLoginForm();
                document.getElementById('login-email').value = email;
                
            } catch (error) {
                console.error('Signup error:', error);
                errorEl.textContent = 'Error creating account: ' + error.message;
                errorEl.classList.remove('hidden');
            } finally {
                hideLoading();
            }
        };

        window.handleCreateSeason = async function() {
            const input = document.getElementById('new-season-name');
            if (await createSeason(input.value)) {
                input.value = '';
            }
        };
        
        // Invite system functions
        window.inviteUser = inviteUser;
        window.resendInvite = resendInvite;
        window.completeInvite = completeInvite;
        
        window.copyInviteLink = function() {
            const input = document.getElementById('invite-url-input');
            if (input) {
                input.select();
                document.execCommand('copy');
                alert('Link copied to clipboard!');
            }
        };
        
        window.sendInviteSMS = function() {
            if (!state.showInviteResult) return;
            const user = state.showInviteResult.user;
            const url = state.showInviteResult.inviteUrl;
            const phone = user.phone?.replace(/\D/g, '');
            const displayName = getUserDisplayName(user);
            const leagueName = state.leagueName || 'Pool League';
            
            const message = `Welcome to ${leagueName}! Set up your account here: ${url}`;
            
            // Open SMS app with pre-filled message
            window.open(`sms:${phone}?body=${encodeURIComponent(message)}`, '_blank');
        };
        
        window.closeInviteModal = function() {
            state.showInviteResult = null;
            render();
        };
        
        window.handleResendInvite = async function(userId) {
            const url = await resendInvite(userId);
            if (url) {
                const user = state.users.find(u => u.id === userId);
                state.showInviteResult = { user, inviteUrl: url };
                state.editingUser = null;
                render();
            }
        };
        
        window.handleCompleteInvite = async function() {
            const password = document.getElementById('setup-password').value;
            const password2 = document.getElementById('setup-password2').value;
            const errorEl = document.getElementById('setup-error');
            
            if (!password || password.length < 4) {
                errorEl.textContent = 'Password must be at least 4 characters';
                errorEl.classList.remove('hidden');
                return;
            }
            
            if (password !== password2) {
                errorEl.textContent = 'Passwords do not match';
                errorEl.classList.remove('hidden');
                return;
            }
            
            const result = await completeInvite(state.inviteToken, password);
            if (result) {
                // Clear invite token from URL and state
                window.history.replaceState({}, document.title, window.location.pathname);
                state.inviteToken = null;
                
                // Pre-fill email on login form
                render();
                setTimeout(() => {
                    const emailInput = document.getElementById('login-email');
                    if (emailInput && result.email) {
                        emailInput.value = result.email;
                    }
                }, 100);
            }
        };

        window.switchSeason = switchSeason;
        window.setActiveSeason = setActiveSeason;
        window.deleteSeason = deleteSeason;
        window.archiveSeason = archiveSeason;
        window.unarchiveSeason = unarchiveSeason;
        window.confirmDeleteSeason = confirmDeleteSeason;
        window.createSeason = createSeason;
        window.generateNewSeasonSchedule = generateNewSeasonSchedule;

        // ============================================
        // MAIN RENDER
        // ============================================
        function render() {
            if (!window.state.initialized) {
                document.getElementById('app').innerHTML = `
                    <div class="min-h-screen bg-gradient-to-br from-slate-900 via-emerald-900 to-teal-900 flex items-center justify-center">
                        <div class="text-center text-white">
                            <div class="spinner mx-auto mb-4"></div>
                            <p class="text-xl">Loading...</p>
                        </div>
                    </div>
                `;
                return;
            }

            const app = document.getElementById('app');
            
            // Check for invite token in URL
            if (window.state.inviteToken) {
                app.innerHTML = renderInviteSetup();
            } else if (!window.state.currentUser) {
                app.innerHTML = renderLoginScreen();
            } else if (window.state.showLeagueSelector) {
                app.innerHTML = renderLeagueSelector();
            } else {
                const tabs = { schedule: renderSchedule, submit: renderSubmitScores, standings: renderStandings, players: renderPlayerStats, history: renderHistory, teams: renderTeams, users: renderUsers, admin: renderAdmin, settings: renderSettings };
                app.innerHTML = `
                    <div class="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
                        ${renderHeader()}
                        ${renderNav()}
                        <main class="max-w-7xl mx-auto px-4 py-6">${tabs[state.activeTab]?.() || ''}</main>
                    </div>
                `;
            }
        }
        
        // Invite setup page for new users
        function renderInviteSetup() {
            return `
                <div class="min-h-screen bg-gradient-to-br from-slate-900 via-emerald-900 to-teal-900 flex items-center justify-center p-4">
                    <div class="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-md border-4 border-emerald-700">
                        <div class="text-center mb-8">
                            <div class="text-6xl mb-4">üé±</div>
                            <h1 class="text-3xl font-black text-slate-800 mb-2">Welcome!</h1>
                            <p class="text-slate-600">Set up your account to get started</p>
                        </div>
                        
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-bold text-slate-700 mb-1">Create Your Password</label>
                                <input type="password" id="setup-password" placeholder="Password (min 4 characters)" 
                                    class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            </div>
                            <div>
                                <label class="block text-sm font-bold text-slate-700 mb-1">Confirm Password</label>
                                <input type="password" id="setup-password2" placeholder="Confirm password" 
                                    class="w-full px-4 py-3 border-2 border-slate-300 rounded-lg">
                            </div>
                            <div id="setup-error" class="hidden bg-red-50 border-2 border-red-200 text-red-700 px-4 py-3 rounded-lg"></div>
                            <button onclick="handleCompleteInvite()" class="w-full bg-gradient-to-r from-emerald-600 to-teal-600 text-white font-bold py-4 rounded-lg hover:from-emerald-700 hover:to-teal-700">
                                üöÄ Activate Account
                            </button>
                            <p class="text-xs text-slate-500 text-center mt-4">
                                After setting your password, you'll be able to sign in and view your league.
                            </p>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // League selector for users in multiple leagues
        function renderLeagueSelector() {
            const leagues = state.userLeagues || [];
            const displayName = getUserDisplayName(state.currentUser);
            
            return `
                <div class="min-h-screen bg-gradient-to-br from-slate-900 via-emerald-900 to-teal-900 flex items-center justify-center p-4">
                    <div class="bg-white rounded-2xl shadow-2xl p-8 w-full max-w-lg border-4 border-emerald-700">
                        <div class="text-center mb-6">
                            <div class="text-5xl mb-3">üé±</div>
                            <h1 class="text-2xl font-black text-slate-800">Welcome, ${displayName}!</h1>
                            <p class="text-slate-600 mt-2">Select a league to continue</p>
                        </div>
                        
                        <div class="space-y-3">
                            ${leagues.map(league => `
                                <button onclick="selectLeague(${JSON.stringify(league).replace(/"/g, '&quot;')})" 
                                    class="w-full p-4 bg-gradient-to-r from-emerald-50 to-teal-50 hover:from-emerald-100 hover:to-teal-100 border-2 border-emerald-200 rounded-xl text-left transition-all hover:shadow-md">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <div class="font-bold text-lg text-emerald-800">${league.leagueName}</div>
                                            <div class="text-sm text-slate-600">${league.orgName}</div>
                                            ${league.teamName ? `<div class="text-xs text-emerald-600 mt-1">üè† ${league.teamName}</div>` : ''}
                                        </div>
                                        <div class="text-right">
                                            <span class="px-2 py-1 bg-emerald-100 text-emerald-700 text-xs font-bold rounded-full">${league.role || 'Member'}</span>
                                        </div>
                                    </div>
                                </button>
                            `).join('')}
                        </div>
                        
                        <div class="mt-6 pt-4 border-t text-center">
                            <button onclick="logout()" class="text-slate-500 hover:text-slate-700 text-sm">
                                ‚Üê Sign out and use a different account
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        // ============================================
        // INIT
        // ============================================
        async function init() {
            render(); // Show loading screen
            
            // Check for invite token in URL
            const urlParams = new URLSearchParams(window.location.search);
            const inviteToken = urlParams.get('invite');
            if (inviteToken) {
                state.inviteToken = inviteToken;
                state.initialized = true;
                render();
                return; // Don't load session, just show setup page
            }
            
            const session = localStorage.getItem('plm_session');
            if (session) {
                try {
                    const { id } = JSON.parse(session);
                    
                    // Load user
                    const { data: userData, error } = await db.from('users')
                        .select('*')
                        .eq('id', id)
                        .single();
                    
                    if (userData && !error) {
                        const user = {
                            id: userData.id, email: userData.email, password: userData.password,
                            firstName: userData.first_name || '', lastName: userData.last_name || '',
                            phone: userData.phone, role: userData.role, teamId: userData.team_id,
                            playerId: userData.player_id, createdAt: userData.created_at,
                            createdBy: userData.created_by, orgId: userData.org_id
                        };
                        
                        state.currentUser = user;
                        
                        // Check for league memberships
                        const leagues = await getUserLeagues(user.id);
                        state.userLeagues = leagues;
                        
                        // Get saved league selection
                        const savedLeague = localStorage.getItem('plm_selected_league');
                        let selectedLeague = null;
                        
                        if (savedLeague) {
                            try {
                                const { leagueId, orgId } = JSON.parse(savedLeague);
                                // Find the matching league in user's leagues
                                selectedLeague = leagues.find(l => 
                                    (leagueId && l.leagueId === leagueId) || 
                                    (orgId && l.orgId === orgId)
                                );
                            } catch (e) {
                                console.log('Error parsing saved league:', e);
                            }
                        }
                        
                        if (leagues.length === 0) {
                            // Fall back to legacy org_id method
                            if (user.orgId) {
                                await loadOrganizationAndData(user.orgId);
                            } else {
                                localStorage.removeItem('plm_session');
                                alert('No league access found. Contact your league administrator.');
                            }
                        } else if (leagues.length === 1) {
                            // Auto-select the only league
                            await selectLeague(leagues[0]);
                        } else if (selectedLeague) {
                            // Use saved league selection
                            await selectLeague(selectedLeague);
                        } else {
                            // Multiple leagues, no saved selection - show selector
                            state.showLeagueSelector = true;
                        }
                    } else {
                        localStorage.removeItem('plm_session');
                        localStorage.removeItem('plm_selected_league');
                    }
                } catch (e) {
                    console.error('Session restore error:', e);
                    localStorage.removeItem('plm_session');
                    localStorage.removeItem('plm_selected_league');
                }
            }

            // Always mark as initialized so login screen shows
            state.initialized = true;
            render();
            console.log('App loaded with Supabase!');
        }

        // ============================================
        // EXPOSE TO WINDOW (for onclick handlers)
        // ============================================
        window.state = state;
        window.render = render;
        window.logout = logout;
        window.selectLeague = selectLeague;
        window.submitScores = submitScores;
        window.generateSchedule = generateSchedule;
        window.deleteScheduleMatch = deleteScheduleMatch;
        window.markAsPlayed = markAsPlayed;
        window.deleteTeam = deleteTeam;
        window.setTeamCaptain = setTeamCaptain;
        window.deleteUser = deleteUser;
        window.editUser = editUser;
        window.saveUser = saveUser;
        window.cancelEditUser = cancelEditUser;
        window.updateEditingUser = updateEditingUser;
        window.assignTeam = assignTeam;
        window.removePlayer = removePlayer;
        window.approveSubmission = approveSubmission;
        window.rejectBoth = rejectBoth;
        window.clearAllData = clearAllData;
        window.addVenue = addVenue;
        window.deleteVenue = deleteVenue;
        
        // Standings adjustment functions
        window.saveStandingsAdjustments = saveStandingsAdjustments;
        window.updateStandingsAdjustment = updateStandingsAdjustment;
        window.quickAdjust = quickAdjust;
        
        // Player stats adjustment functions
        window.savePlayerStatsAdjustments = savePlayerStatsAdjustments;
        window.updatePlayerStatsAdjustment = updatePlayerStatsAdjustment;
        window.quickPlayerAdjust = quickPlayerAdjust;
        
        // Schedule creation functions
        window.addManualMatch = addManualMatch;
        window.importScheduleFromCSV = importScheduleFromCSV;
        window.updateManualVenue = function() {
            const homeTeamId = state.manualMatch.homeTeamId;
            const homeTeam = state.teams.find(t => t.id === homeTeamId);
            if (homeTeam && homeTeam.venue) {
                state.manualMatch.venue = homeTeam.venue;
            }
            render(); // Re-render to update the dropdown selection
        };
        
        // Manual entry helper functions
        window.toggleManualPlayDay = toggleManualPlayDay;
        window.advanceToNextWeek = advanceToNextWeek;
        window.initManualEntryDefaults = initManualEntryDefaults;
        
        // Week entry functions
        window.initWeekMatches = initWeekMatches;
        window.updateWeekMatch = updateWeekMatch;
        window.addWeekMatches = addWeekMatches;
        window.addPositionNightMatches = addPositionNightMatches;
        window.getAvailableTeamsForSlot = getAvailableTeamsForSlot;
        window.getUsedTeamsInWeek = getUsedTeamsInWeek;
        
        window.quickCreateSeason = async function() {
            const nameInput = document.getElementById('quick-season-name');
            const name = nameInput?.value?.trim();
            if (!name) {
                alert('Please enter a season name');
                return;
            }
            if (!state.organization?.id) {
                alert('No organization loaded');
                return;
            }
            showLoading();
            try {
                const { data, error } = await db.from('seasons').insert([{
                    name: name,
                    is_active: true,
                    org_id: state.organization.id
                }]).select().single();
                
                if (error) throw error;
                
                const newSeason = {
                    id: data.id,
                    name: data.name,
                    isActive: true,
                    createdAt: data.created_at,
                    orgId: data.org_id
                };
                
                // Deactivate other seasons
                await db.from('seasons').update({ is_active: false }).neq('id', data.id).eq('org_id', state.organization.id);
                state.seasons = state.seasons.map(s => ({ ...s, isActive: false }));
                
                state.seasons.unshift(newSeason);
                state.currentSeason = newSeason;
                
                alert('Season created! Now you can add matches.');
                render();
            } catch (error) {
                console.error('Error creating season:', error);
                alert('Error creating season: ' + error.message);
            } finally {
                hideLoading();
            }
        };
        window.generateRoundRobinScheduleFromUI = async function() {
            const startDate = document.getElementById('rr-start-date')?.value;
            if (!startDate) {
                alert('Please select a start date');
                return;
            }
            if (state.teams.length < 2) {
                alert('Need at least 2 teams to generate a schedule');
                return;
            }
            
            const confirmMsg = `Generate round-robin schedule for "${state.currentSeason?.name}"?\n\nThis will DELETE all existing matches in this season and create a new schedule.`;
            if (!confirm(confirmMsg)) return;
            
            showLoading();
            try {
                const seasonId = state.currentSeason.id;
                const orgId = state.organization.id;
                
                // Clear existing schedule for this season
                await db.from('matches').delete().eq('season_id', seasonId);
                await db.from('submissions').delete().eq('season_id', seasonId);
                await db.from('schedule').delete().eq('season_id', seasonId);
                
                const numTeams = state.teams.length;
                const weeksPerHalf = numTeams % 2 === 1 ? numTeams : numTeams - 1;
                const schedule = generateRoundRobinSchedule(startDate, weeksPerHalf);
                
                const dbSchedule = schedule.map(s => ({
                    week: s.week, date: s.date, home_team_id: s.homeTeamId,
                    away_team_id: s.awayTeamId, venue: s.venue, is_bye: s.isBye,
                    half: s.half, is_position_night: s.isPositionNight,
                    position_home: s.positionHome, position_away: s.positionAway,
                    season_id: seasonId, org_id: orgId
                }));
                
                const { data } = await db.from('schedule').insert(dbSchedule).select();
                
                state.schedule = data.map(s => ({
                    id: s.id, week: s.week, date: s.date, homeTeamId: s.home_team_id,
                    awayTeamId: s.away_team_id, venue: s.venue, isBye: s.is_bye,
                    half: s.half, isPositionNight: s.is_position_night,
                    positionHome: s.position_home, positionAway: s.position_away,
                    seasonId: s.season_id, orgId: s.org_id
                }));
                
                state.matches = [];
                state.submissions = [];
                state.scheduleMode = null;
                state.autoGenMode = null;
                
                alert(`Schedule generated! ${weeksPerHalf * 2 + 2} weeks created.`);
                render();
            } catch (error) {
                console.error('Error generating schedule:', error);
                alert('Error generating schedule: ' + error.message);
            } finally {
                hideLoading();
            }
        };
        window.downloadSampleCSV = function() {
            const teamNames = state.teams.map(t => t.name);
            const sampleRows = [
                'week,date,home,away,venue,half',
                `1,2025-01-15,${teamNames[0] || 'Team A'},${teamNames[1] || 'Team B'},${state.teams[0]?.venue || 'Main Hall'},1`,
                `1,2025-01-15,${teamNames[2] || 'Team C'},${teamNames[3] || 'Team D'},${state.teams[2]?.venue || 'Sports Bar'},1`,
                `2,2025-01-22,${teamNames[1] || 'Team B'},${teamNames[2] || 'Team C'},${state.teams[1]?.venue || 'Downtown'},1`,
                `2,2025-01-22,${teamNames[0] || 'Team A'},BYE,,1`
            ];
            
            const blob = new Blob([sampleRows.join('\\n')], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'schedule_template.csv';
            a.click();
            URL.revokeObjectURL(url);
        };

        init();
        } // end startApp
        
        // ============================================
        // PWA SUPPORT
        // ============================================
        
        // Detect if running as installed PWA
        if (window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches) {
            document.body.classList.add('pwa-mode');
        }
        
        // Show install prompt for iOS Safari
        function showInstallPrompt() {
            // Check if already installed or dismissed
            if (window.navigator.standalone) return;
            if (localStorage.getItem('pwa_install_dismissed')) return;
            
            // Only show on iOS Safari
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
            
            if (isIOS && isSafari) {
                setTimeout(() => {
                    const banner = document.createElement('div');
                    banner.className = 'install-banner';
                    banner.innerHTML = `
                        <div style="flex:1;">
                            <div style="font-weight:bold;">Install Pool League</div>
                            <div style="font-size:12px;opacity:0.9;">Tap Share then "Add to Home Screen"</div>
                        </div>
                        <button onclick="this.parentElement.remove();localStorage.setItem('pwa_install_dismissed','1');" 
                                style="background:rgba(255,255,255,0.2);border:none;color:white;padding:8px 16px;border-radius:8px;font-weight:bold;">
                            Got it
                        </button>
                    `;
                    document.body.appendChild(banner);
                }, 3000);
            }
        }
        
        // Show install prompt after login
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(showInstallPrompt, 5000);
        });
        
        // Register Service Worker for offline caching (if served over HTTPS)
        if ('serviceWorker' in navigator && location.protocol === 'https:') {
            // Create inline service worker
            const swCode = `
                const CACHE_NAME = 'pool-league-v1';
                const OFFLINE_URLS = ['/'];
                
                self.addEventListener('install', (event) => {
                    self.skipWaiting();
                });
                
                self.addEventListener('activate', (event) => {
                    event.waitUntil(clients.claim());
                });
                
                self.addEventListener('fetch', (event) => {
                    // Network-first strategy
                    event.respondWith(
                        fetch(event.request)
                            .catch(() => caches.match(event.request))
                    );
                });
            `;
            
            const swBlob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            
            navigator.serviceWorker.register(swUrl).then(reg => {
                console.log('Service Worker registered');
            }).catch(err => {
                console.log('Service Worker registration failed (this is normal for local files):', err);
            });
        }
    </script>
</body>
</html>
